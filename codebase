{
  ".env.example": "# API Server Configuration\nAPI_PORT=8080\n\n# PostgreSQL Database Configuration\nPOSTGRES_USER=user\nPOSTGRES_PASSWORD=password\nPOSTGRES_DB=secure_supply_chain\nDATABASE_URL=postgres://user:password@db:5432/secure_supply_chain?sslmode=disable\n\n# MinIO Configuration (placeholders for now)\nMINIO_ENDPOINT=minio:9000\nMINIO_ACCESS_KEY=minioadmin\nMINIO_SECRET_KEY=minioadmin\nMINIO_USE_SSL=false\n",
  ".gitignore": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n\n# Go workspace file\ngo.work\ngo.work.sum\n\n# Environment variables\n.env\n\n# Docker\ndocker-compose.override.yml\ndocker-compose.local.yml\n\n# Build\n/build\n/dist\n\n# IDE\n.idea/\n.vscode/\n*.swp\n*~\n",
  "Makefile": ".PHONY: up down logs db-reset\n\nup:\n\tdocker-compose up -d --build\n\ndown:\n\tdocker-compose down\n\nlogs:\n\tdocker-compose logs -f backend\n\ndb-reset:\n\tdocker-compose down -v\n\tdocker-compose up -d db\n\t@echo \"Waiting for database to be ready...\"\n\t@sleep 5\n\tdocker-compose up -d backend frontend minio\n",
  "backend/Dockerfile": "# Stage 1: Build the application\nFROM golang:1.21-alpine AS builder\n\nWORKDIR /app\n\n# Copy go.mod and go.sum files to download dependencies\nCOPY go.mod go.sum ./\nRUN go mod download\n\n# Copy the rest of the application source code\nCOPY . .\n\n# Build the application\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o secure-image-service ./cmd/server\n\n# Stage 2: Create the final, smaller image\nFROM alpine:latest\n\nWORKDIR /root/\n\n# Copy the binary from the builder stage\nCOPY --from=builder /app/secure-image-service .\n\n# Expose the port the app runs on\nEXPOSE 8080\n\n# Command to run the executable\nCMD [\"./secure-image-service\"]\n",
  "backend/cmd/server/main.go": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"secure-image-service/internal/adapter/handler/http_handler\"\n\t\"secure-image-service/internal/adapter/postgres\"\n\t\"secure-image-service/internal/usecase\"\n\t\"secure-image-service/pkg/config\"\n\t\"secure-image-service/pkg/logger\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/joho/godotenv\"\n)\n\nfunc main() {\n\t// Load .env file for local development\n\t_ = godotenv.Load()\n\n\tlog := logger.New()\n\n\tcfg, err := config.Load()\n\tif err != nil {\n\t\tlog.Fatal().Err(err).Msg(\"Failed to load configuration\")\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// Setup graceful shutdown\n\tstop := make(chan os.Signal, 1)\n\tsignal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)\n\n\t// Database connection\n\tdbpool, err := postgres.NewConnection(ctx, cfg.DatabaseURL)\n\tif err != nil {\n\t\tlog.Fatal().Err(err).Msg(\"Failed to connect to database\")\n\t}\n\tdefer dbpool.Close()\n\tlog.Info().Msg(\"Database connection established\")\n\n\t// Initialize repositories\n\timageRepo := postgres.NewImageRepository(dbpool)\n\tcustomerRepo := postgres.NewCustomerRepository(dbpool)\n\n\t// Initialize use cases\n\timageUsecase := usecase.NewImageUsecase(imageRepo)\n\tcustomerUsecase := usecase.NewCustomerUsecase(customerRepo)\n\n\t// Initialize HTTP server\n\tserver := http_handler.NewServer(imageUsecase, customerUsecase, log)\n\thttpServer := \u0026http.Server{\n\t\tAddr:    \":\" + cfg.APIPort,\n\t\tHandler: server.Router,\n\t}\n\n\t// Start server in a goroutine\n\tgo func() {\n\t\tlog.Info().Msgf(\"Starting server on port %s\", cfg.APIPort)\n\t\tif err := httpServer.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlog.Fatal().Err(err).Msg(\"Server failed to start\")\n\t\t}\n\t}()\n\n\t// Wait for shutdown signal\n\t\u003c-stop\n\tlog.Info().Msg(\"Shutting down server...\")\n\n\t// Graceful shutdown\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := httpServer.Shutdown(shutdownCtx); err != nil {\n\t\tlog.Fatal().Err(err).Msg(\"Server shutdown failed\")\n\t}\n\n\tlog.Info().Msg(\"Server gracefully stopped\")\n}\n",
  "backend/go.mod": "module secure-image-service\n\ngo 1.21\n\nrequire (\n\tgithub.com/go-chi/chi/v5 v5.0.12\n\tgithub.com/jackc/pgx/v5 v5.5.5\n\tgithub.com/joho/godotenv v1.5.1\n\tgithub.com/rs/zerolog v1.32.0\n)\n\nrequire (\n\tgithub.com/jackc/pgpassfile v1.0.0 // indirect\n\tgithub.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect\n\tgithub.com/jackc/puddle/v2 v2.2.1 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.19 // indirect\n\tgolang.org/x/crypto v0.17.0 // indirect\n\tgolang.org/x/sync v0.1.0 // indirect\n\tgolang.org/x/sys v0.15.0 // indirect\n\tgolang.org/x/text v0.14.0 // indirect\n)\n",
  "backend/internal/adapter/handler/http/customer_handler.go": "package http\n\nimport (\n\t\"net/http\"\n\t\"secure-image-service/internal/usecase\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype CustomerHandler struct {\n\tusecase *usecase.CustomerUsecase\n}\n\nfunc NewCustomerHandler(uc *usecase.CustomerUsecase) *CustomerHandler {\n\treturn \u0026CustomerHandler{usecase: uc}\n}\n\nfunc (h *CustomerHandler) ListCustomers(w http.ResponseWriter, r *http.Request) {\n\tcustomers, err := h.usecase.ListCustomers(r.Context())\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, \"Failed to retrieve customers\")\n\t\treturn\n\t}\n\trespondWithJSON(w, http.StatusOK, customers)\n}\n\nfunc (h *CustomerHandler) GetCustomer(w http.ResponseWriter, r *http.Request) {\n\tnamespace := chi.URLParam(r, \"namespace\")\n\tcustomer, err := h.usecase.GetCustomer(r.Context(), namespace)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, \"Failed to retrieve customer\")\n\t\treturn\n\t}\n\tif customer == nil {\n\t\trespondWithError(w, http.StatusNotFound, \"Customer not found\")\n\t\treturn\n\t}\n\trespondWithJSON(w, http.StatusOK, customer)\n}\n",
  "backend/internal/adapter/handler/http/image_handler.go": "package http\n\nimport (\n\t\"net/http\"\n\t\"secure-image-service/internal/usecase\"\n\t\"strconv\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype ImageHandler struct {\n\tusecase *usecase.ImageUsecase\n}\n\nfunc NewImageHandler(uc *usecase.ImageUsecase) *ImageHandler {\n\treturn \u0026ImageHandler{usecase: uc}\n}\n\nfunc (h *ImageHandler) ListImages(w http.ResponseWriter, r *http.Request) {\n\timages, err := h.usecase.ListImages(r.Context())\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, \"Failed to retrieve images\")\n\t\treturn\n\t}\n\trespondWithJSON(w, http.StatusOK, images)\n}\n\nfunc (h *ImageHandler) GetImage(w http.ResponseWriter, r *http.Request) {\n\tidStr := chi.URLParam(r, \"id\")\n\tid, err := strconv.Atoi(idStr)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusBadRequest, \"Invalid image ID\")\n\t\treturn\n\t}\n\n\timage, err := h.usecase.GetImage(r.Context(), id)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, \"Failed to retrieve image\")\n\t\treturn\n\t}\n\tif image == nil {\n\t\trespondWithError(w, http.StatusNotFound, \"Image not found\")\n\t\treturn\n\t}\n\trespondWithJSON(w, http.StatusOK, image)\n}\n",
  "backend/internal/adapter/handler/http/server.go": "package http\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"secure-image-service/internal/usecase\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n\t\"github.com/rs/zerolog\"\n)\n\ntype Server struct {\n\tRouter          *chi.Mux\n\tImageHandler    *ImageHandler\n\tCustomerHandler *CustomerHandler\n\tLogger          zerolog.Logger\n}\n\nfunc NewServer(imageUsecase *usecase.ImageUsecase, customerUsecase *usecase.CustomerUsecase, logger zerolog.Logger) *Server {\n\ts := \u0026Server{\n\t\tRouter:          chi.NewRouter(),\n\t\tImageHandler:    NewImageHandler(imageUsecase),\n\t\tCustomerHandler: NewCustomerHandler(customerUsecase),\n\t\tLogger:          logger,\n\t}\n\ts.setupRoutes()\n\treturn s\n}\n\nfunc (s *Server) setupRoutes() {\n\ts.Router.Use(middleware.RequestID)\n\ts.Router.Use(middleware.RealIP)\n\ts.Router.Use(middleware.Logger)\n\ts.Router.Use(middleware.Recoverer)\n\n\ts.Router.Get(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\ts.Router.Route(\"/v1\", func(r chi.Router) {\n\t\tr.Get(\"/images\", s.ImageHandler.ListImages)\n\t\tr.Get(\"/images/{id}\", s.ImageHandler.GetImage)\n\n\t\tr.Get(\"/customers\", s.CustomerHandler.ListCustomers)\n\t\tr.Get(\"/customers/{namespace}\", s.CustomerHandler.GetCustomer)\n\t})\n}\n\nfunc (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\ts.Router.ServeHTTP(w, r)\n}\n\nfunc respondWithError(w http.ResponseWriter, code int, message string) {\n\trespondWithJSON(w, code, map[string]string{\"error\": message})\n}\n\nfunc respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {\n\tresponse, _ := json.Marshal(payload)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(code)\n\tw.Write(response)\n}\n",
  "backend/internal/adapter/postgres/customer_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype pgCustomerRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewCustomerRepository(db *pgxpool.Pool) repository.CustomerRepository {\n\treturn \u0026pgCustomerRepository{db: db}\n}\n\nfunc (r *pgCustomerRepository) FindAll(ctx context.Context) ([]*domain.Customer, error) {\n\trows, err := r.db.Query(ctx, \"SELECT namespace, name, contact_info, sla_tier, created_at, updated_at FROM customers ORDER BY name\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tcustomers, err := pgx.CollectRows(rows, pgx.RowToAddrOfStructByPos[domain.Customer])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn customers, nil\n}\n\nfunc (r *pgCustomerRepository) FindByNamespace(ctx context.Context, namespace string) (*domain.Customer, error) {\n\trow := r.db.QueryRow(ctx, \"SELECT namespace, name, contact_info, sla_tier, created_at, updated_at FROM customers WHERE namespace = $1\", namespace)\n\n\tcustomer, err := pgx.RowToAddrOfStructByPos[domain.Customer](row)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil // Not found is not an error\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn customer, nil\n}\n",
  "backend/internal/adapter/postgres/db.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\nfunc NewConnection(ctx context.Context, connString string) (*pgxpool.Pool, error) {\n\tpool, err := pgxpool.New(ctx, connString)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create connection pool: %w\", err)\n\t}\n\n\tif err := pool.Ping(ctx); err != nil {\n\t\tpool.Close()\n\t\treturn nil, fmt.Errorf(\"unable to ping database: %w\", err)\n\t}\n\n\treturn pool, nil\n}\n",
  "backend/internal/adapter/postgres/image_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype pgImageRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewImageRepository(db *pgxpool.Pool) repository.ImageRepository {\n\treturn \u0026pgImageRepository{db: db}\n}\n\nfunc (r *pgImageRepository) FindAll(ctx context.Context) ([]*domain.Image, error) {\n\trows, err := r.db.Query(ctx, \"SELECT id, tenant_namespace, digest, tags, slsa_level, created_at, updated_at FROM images ORDER BY created_at DESC\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\timages, err := pgx.CollectRows(rows, pgx.RowToAddrOfStructByPos[domain.Image])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn images, nil\n}\n\nfunc (r *pgImageRepository) FindByID(ctx context.Context, id int) (*domain.Image, error) {\n\trow := r.db.QueryRow(ctx, \"SELECT id, tenant_namespace, digest, tags, slsa_level, created_at, updated_at FROM images WHERE id = $1\", id)\n\n\timage, err := pgx.RowToAddrOfStructByPos[domain.Image](row)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil // Not found is not an error\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn image, nil\n}\n",
  "backend/internal/domain/customer.go": "package domain\n\nimport \"time\"\n\ntype Customer struct {\n\tNamespace    string    `json:\"namespace\"`\n\tName         string    `json:\"name\"`\n\tContactInfo  string    `json:\"contact_info\"`\n\tSLATier      string    `json:\"sla_tier\"`\n\tCreatedAt    time.Time `json:\"created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\"`\n}\n",
  "backend/internal/domain/image.go": "package domain\n\nimport (\n\t\"time\"\n)\n\ntype Image struct {\n\tID              int       `json:\"id\"`\n\tTenantNamespace string    `json:\"tenant_namespace\"`\n\tDigest          string    `json:\"digest\"`\n\tTags            []string  `json:\"tags\"`\n\tSLSALevel       int       `json:\"slsa_level\"`\n\tCreatedAt       time.Time `json:\"created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\"`\n}\n",
  "backend/internal/repository/customer.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n)\n\ntype CustomerRepository interface {\n\tFindAll(ctx context.Context) ([]*domain.Customer, error)\n\tFindByNamespace(ctx context.Context, namespace string) (*domain.Customer, error)\n}\n",
  "backend/internal/repository/image.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n)\n\ntype ImageRepository interface {\n\tFindAll(ctx context.Context) ([]*domain.Image, error)\n\tFindByID(ctx context.Context, id int) (*domain.Image, error)\n}\n",
  "backend/internal/usecase/customer_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\ntype CustomerUsecase struct {\n\trepo repository.CustomerRepository\n}\n\nfunc NewCustomerUsecase(repo repository.CustomerRepository) *CustomerUsecase {\n\treturn \u0026CustomerUsecase{repo: repo}\n}\n\nfunc (uc *CustomerUsecase) ListCustomers(ctx context.Context) ([]*domain.Customer, error) {\n\treturn uc.repo.FindAll(ctx)\n}\n\nfunc (uc *CustomerUsecase) GetCustomer(ctx context.Context, namespace string) (*domain.Customer, error) {\n\treturn uc.repo.FindByNamespace(ctx, namespace)\n}\n",
  "backend/internal/usecase/image_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\ntype ImageUsecase struct {\n\trepo repository.ImageRepository\n}\n\nfunc NewImageUsecase(repo repository.ImageRepository) *ImageUsecase {\n\treturn \u0026ImageUsecase{repo: repo}\n}\n\nfunc (uc *ImageUsecase) ListImages(ctx context.Context) ([]*domain.Image, error) {\n\treturn uc.repo.FindAll(ctx)\n}\n\nfunc (uc *ImageUsecase) GetImage(ctx context.Context, id int) (*domain.Image, error) {\n\treturn uc.repo.FindByID(ctx, id)\n}\n",
  "backend/pkg/config/config.go": "package config\n\nimport (\n\t\"os\"\n\t\"strconv\"\n)\n\ntype Config struct {\n\tDatabaseURL string\n\tAPIPort     string\n}\n\nfunc Load() (*Config, error) {\n\tport := os.Getenv(\"API_PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\n\t// Validate port is a number\n\tif _, err := strconv.Atoi(port); err != nil {\n\t\tport = \"8080\"\n\t}\n\n\treturn \u0026Config{\n\t\tDatabaseURL: os.Getenv(\"DATABASE_URL\"),\n\t\tAPIPort:     port,\n\t}, nil\n}\n",
  "backend/pkg/logger/logger.go": "package logger\n\nimport (\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog\"\n)\n\nfunc New() zerolog.Logger {\n\treturn zerolog.New(zerolog.ConsoleWriter{Out: os.Stderr, TimeFormat: time.RFC3339}).\n\t\tLevel(zerolog.TraceLevel).\n\t\tWith().\n\t\tTimestamp().\n\t\tLogger()\n}\n",
  "deployments/docker-compose.yml": "version: '3.8'\n\nservices:\n  db:\n    image: postgres:14-alpine\n    container_name: ssc-db\n    environment:\n      POSTGRES_DB: ${POSTGRES_DB}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./seed/init.sql:/docker-entrypoint-initdb.d/init.sql\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n\n  minio:\n    image: minio/minio:latest\n    container_name: ssc-minio\n    ports:\n      - \"9000:9000\"\n      - \"9001:9001\"\n    environment:\n      MINIO_ROOT_USER: ${MINIO_ACCESS_KEY}\n      MINIO_ROOT_PASSWORD: ${MINIO_SECRET_KEY}\n    command: server /data --console-address \":9001\"\n    volumes:\n      - minio_data:/data\n\n  backend:\n    build:\n      context: ../backend\n      dockerfile: Dockerfile\n    container_name: ssc-backend\n    ports:\n      - \"${API_PORT}:${API_PORT}\"\n    depends_on:\n      db:\n        condition: service_healthy\n    environment:\n      - DATABASE_URL=${DATABASE_URL}\n      - API_PORT=${API_PORT}\n    env_file:\n      - ../.env\n\n  frontend:\n    image: nginx:alpine\n    container_name: ssc-frontend\n    ports:\n      - \"80:80\"\n    volumes:\n      - ../frontend:/usr/share/nginx/html\n    depends_on:\n      - backend\n\nvolumes:\n  postgres_data:\n  minio_data:\n",
  "deployments/seed/init.sql": "-- Enable extensions\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n-- Create customers table to represent tenants\nCREATE TABLE customers (\n    namespace VARCHAR(255) PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    contact_info VARCHAR(255),\n    sla_tier VARCHAR(50) NOT NULL DEFAULT 'standard',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\n-- Create images table\nCREATE TABLE images (\n    id SERIAL PRIMARY KEY,\n    tenant_namespace VARCHAR(255) NOT NULL REFERENCES customers(namespace),\n    digest VARCHAR(255) NOT NULL UNIQUE,\n    tags TEXT[],\n    slsa_level INT,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\n-- Seed data for customers\nINSERT INTO customers (namespace, name, contact_info, sla_tier) VALUES\n('acme-corp', 'ACME Corporation', 'security@acme.corp', 'premium'),\n('startup-inc', 'Startup Inc.', 'devops@startup.inc', 'standard');\n\n-- Seed data for images\nINSERT INTO images (tenant_namespace, digest, tags, slsa_level) VALUES\n('acme-corp', 'sha256:c3d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3', ARRAY['latest', '1.2.3'], 3),\n('acme-corp', 'sha256:abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890', ARRAY['1.2.2'], 3),\n('startup-inc', 'sha256:fedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321', ARRAY['latest'], 1),\n('startup-inc', 'sha256:11223344556677889900aabbccddeeff11223344556677889900aabbccddeeff', ARRAY['v2-beta'], 1);\n\n-- Create indexes for performance\nCREATE INDEX idx_images_tenant_namespace ON images(tenant_namespace);\n",
  "frontend/css/style.css": "body {\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n    line-height: 1.6;\n    background-color: #f4f4f4;\n    color: #333;\n    margin: 0;\n    padding: 20px;\n}\n\nheader {\n    background-color: #333;\n    color: #fff;\n    padding: 1rem;\n    text-align: center;\n    margin-bottom: 20px;\n}\n\nmain {\n    max-width: 960px;\n    margin: auto;\n    background: #fff;\n    padding: 20px;\n    border-radius: 5px;\n}\n\nh1, h2 {\n    color: #333;\n}\n",
  "frontend/index.html": "\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eSecure Software Supply Chain MVP\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"css/style.css\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cheader\u003e\n        \u003ch1\u003eSecure Software Supply Chain Platform\u003c/h1\u003e\n    \u003c/header\u003e\n    \u003cmain\u003e\n        \u003ch2\u003eImage Explorer\u003c/h2\u003e\n        \u003cp\u003eThis is a placeholder for the image explorer UI.\u003c/p\u003e\n        \u003cp\u003eFrontend application will be built in future steps.\u003c/p\u003e\n    \u003c/main\u003e\n    \u003cscript src=\"js/main.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n",
  "frontend/js/main.js": "console.log(\"Secure Software Supply Chain Frontend Initialized.\");\n```"
}