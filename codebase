{
  ".env.example": "# API Server Configuration\nAPI_PORT=8080\n\n# PostgreSQL Database Configuration\nPOSTGRES_USER=user\nPOSTGRES_PASSWORD=password\nPOSTGRES_DB=secure_supply_chain\nDATABASE_URL=postgres://user:password@db:5432/secure_supply_chain?sslmode=disable\n\n# MinIO Configuration (placeholders for now)\nMINIO_ENDPOINT=minio:9000\nMINIO_ACCESS_KEY=minioadmin\nMINIO_SECRET_KEY=minioadmin\nMINIO_USE_SSL=false\n",
  ".gitignore": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n\n# Go workspace file\ngo.work\ngo.work.sum\n\n# Environment variables\n.env\n\n# Docker\ndocker-compose.override.yml\ndocker-compose.local.yml\n\n# Build\n/build\n/dist\n\n# IDE\n.idea/\n.vscode/\n*.swp\n*~\n",
  "Makefile": ".PHONY: up down logs db-reset\n\nup:\n\tdocker-compose up -d --build\n\ndown:\n\tdocker-compose down\n\nlogs:\n\tdocker-compose logs -f backend\n\ndb-reset:\n\tdocker-compose down -v\n\tdocker-compose up -d db\n\t@echo \"Waiting for database to be ready...\"\n\t@sleep 5\n\tdocker-compose up -d backend frontend minio\n",
  "backend/Dockerfile": "# Stage 1: Build the application\nFROM golang:1.21-alpine AS builder\n\nWORKDIR /app\n\n# Copy go.mod and go.sum files to download dependencies\nCOPY go.mod go.sum ./\nRUN go mod download\n\n# Copy the rest of the application source code\nCOPY . .\n\n# Build the application\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o secure-image-service ./cmd/server\n\n# Stage 2: Create the final, smaller image\nFROM alpine:latest\n\nWORKDIR /root/\n\n# Copy the binary from the builder stage\nCOPY --from=builder /app/secure-image-service .\n\n# Expose the port the app runs on\nEXPOSE 8080\n\n# Command to run the executable\nCMD [\"./secure-image-service\"]\n",
  "backend/cmd/server/main.go": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/joho/godotenv\"\n\thttp_handler \"secure-image-service/internal/adapter/handler/http\"\n\t\"secure-image-service/internal/adapter/postgres\"\n\t\"secure-image-service/internal/adapter/simulator\"\n\t\"secure-image-service/internal/usecase\"\n\t\"secure-image-service/pkg/config\"\n\t\"secure-image-service/pkg/logger\"\n)\n\nfunc main() {\n\t// Load .env file for local development\n\tif err := godotenv.Load(); err != nil {\n\t\tfmt.Println(\"No .env file found, using environment variables\")\n\t}\n\n\t// Initialize logger\n\tappLogger := logger.New()\n\n\t// Load configuration\n\tcfg, err := config.Load()\n\tif err != nil {\n\t\tappLogger.Fatal().Err(err).Msg(\"Failed to load configuration\")\n\t}\n\n\t// Set up context for graceful shutdown\n\tctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)\n\tdefer stop()\n\n\t// Establish database connection\n\tdbPool, err := postgres.NewConnection(ctx, cfg.DatabaseURL)\n\tif err != nil {\n\t\tappLogger.Fatal().Err(err).Msg(\"Failed to connect to database\")\n\t}\n\tdefer dbPool.Close()\n\tappLogger.Info().Msg(\"Database connection established\")\n\n\t// Initialize repositories\n\timageRepo := postgres.NewImageRepository(dbPool)\n\tcustomerRepo := postgres.NewCustomerRepository(dbPool)\n\tbuildEventRepo := postgres.NewBuildEventRepository(dbPool)\n\tsbomRepo := postgres.NewSBOMRecordRepository(dbPool)\n\tcveRepo := postgres.NewCVEFindingRepository(dbPool)\n\n\t// Initialize simulators\n\torchestrator := simulator.NewMockBuildOrchestrator()\n\n\t// Initialize use cases\n\timageUsecase := usecase.NewImageUsecase(imageRepo, buildEventRepo, orchestrator)\n\tcustomerUsecase := usecase.NewCustomerUsecase(customerRepo)\n\tbuildUsecase := usecase.NewBuildUsecase(buildEventRepo, imageRepo, sbomRepo, cveRepo)\n\n\t// Initialize HTTP server\n\tserver := http_handler.NewServer(imageUsecase, customerUsecase, buildUsecase, appLogger)\n\thttpServer := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\":%s\", cfg.APIPort),\n\t\tHandler: server,\n\t}\n\n\t// Start server in a goroutine\n\tgo func() {\n\t\tappLogger.Info().Msgf(\"Server starting on port %s\", cfg.APIPort)\n\t\tif err := httpServer.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tappLogger.Fatal().Err(err).Msg(\"Server failed to start\")\n\t\t}\n\t}()\n\n\t// Wait for shutdown signal\n\t\u003c-ctx.Done()\n\n\t// Graceful shutdown\n\tappLogger.Info().Msg(\"Shutting down server...\")\n\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tif err := httpServer.Shutdown(shutdownCtx); err != nil {\n\t\tappLogger.Fatal().Err(err).Msg(\"Server shutdown failed\")\n\t}\n\n\tappLogger.Info().Msg(\"Server gracefully stopped\")\n}",
  "backend/go.mod": "module secure-image-service\n\ngo 1.21\n\nrequire (\n\tgithub.com/go-chi/chi/v5 v5.0.12\n\tgithub.com/jackc/pgx/v5 v5.5.5\n\tgithub.com/joho/godotenv v1.5.1\n\tgithub.com/rs/zerolog v1.32.0\n)\n\nrequire (\n\tgithub.com/jackc/pgpassfile v1.0.0 // indirect\n\tgithub.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect\n\tgithub.com/jackc/puddle/v2 v2.2.1 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.19 // indirect\n\tgolang.org/x/crypto v0.17.0 // indirect\n\tgolang.org/x/sync v0.1.0 // indirect\n\tgolang.org/x/sys v0.15.0 // indirect\n\tgolang.org/x/text v0.14.0 // indirect\n)\n",
  "backend/internal/adapter/handler/http/build_handler.go": "package http\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"secure-image-service/internal/usecase\"\n\t\"strconv\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype BuildHandler struct {\n\tusecase *usecase.BuildUsecase\n}\n\nfunc NewBuildHandler(uc *usecase.BuildUsecase) *BuildHandler {\n\treturn \u0026BuildHandler{usecase: uc}\n}\n\nfunc (h *BuildHandler) CompleteBuild(w http.ResponseWriter, r *http.Request) {\n\tbuildIDStr := chi.URLParam(r, \"buildID\")\n\tbuildID, err := strconv.Atoi(buildIDStr)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusBadRequest, \"Invalid build ID\")\n\t\treturn\n\t}\n\n\tvar req usecase.BuildCompletionRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\trespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\timage, err := h.usecase.CompleteBuild(r.Context(), buildID, req)\n\tif err != nil {\n\t\t// Consider more specific error codes based on err type\n\t\trespondWithError(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusCreated, image)\n}\n",
  "backend/internal/adapter/handler/http/customer_handler.go": "package http\n\nimport (\n\t\"net/http\"\n\t\"secure-image-service/internal/usecase\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype CustomerHandler struct {\n\tusecase *usecase.CustomerUsecase\n}\n\nfunc NewCustomerHandler(uc *usecase.CustomerUsecase) *CustomerHandler {\n\treturn \u0026CustomerHandler{usecase: uc}\n}\n\nfunc (h *CustomerHandler) ListCustomers(w http.ResponseWriter, r *http.Request) {\n\tcustomers, err := h.usecase.ListCustomers(r.Context())\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, \"Failed to retrieve customers\")\n\t\treturn\n\t}\n\trespondWithJSON(w, http.StatusOK, customers)\n}\n\nfunc (h *CustomerHandler) GetCustomer(w http.ResponseWriter, r *http.Request) {\n\tnamespace := chi.URLParam(r, \"namespace\")\n\tcustomer, err := h.usecase.GetCustomer(r.Context(), namespace)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, \"Failed to retrieve customer\")\n\t\treturn\n\t}\n\tif customer == nil {\n\t\trespondWithError(w, http.StatusNotFound, \"Customer not found\")\n\t\treturn\n\t}\n\trespondWithJSON(w, http.StatusOK, customer)\n}\n",
  "backend/internal/adapter/handler/http/image_handler.go": "package http\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"secure-image-service/internal/usecase\"\n)\n\n// ImageHandler handles HTTP requests for images.\ntype ImageHandler struct {\n\tusecase *usecase.ImageUsecase\n}\n\n// NewImageHandler creates a new ImageHandler.\nfunc NewImageHandler(uc *usecase.ImageUsecase) *ImageHandler {\n\treturn \u0026ImageHandler{usecase: uc}\n}\n\ntype CreateBuildRequest struct {\n\tTenantNamespace string `json:\"tenant_namespace\"`\n}\n\n// CreateBuild handles POST requests to trigger a new image build.\nfunc (h *ImageHandler) CreateBuild(w http.ResponseWriter, r *http.Request) {\n\tvar req CreateBuildRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\trespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\tif req.TenantNamespace == \"\" {\n\t\trespondWithError(w, http.StatusBadRequest, \"tenant_namespace is required\")\n\t\treturn\n\t}\n\n\t// For now, all builds are triggered via API\n\ttriggerType := \"api\"\n\n\tbuildEvent, err := h.usecase.CreateBuild(r.Context(), req.TenantNamespace, triggerType)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusAccepted, buildEvent)\n}\n\n// ListImages handles GET requests to retrieve all images.\nfunc (h *ImageHandler) ListImages(w http.ResponseWriter, r *http.Request) {\n\timages, err := h.usecase.ListImages(r.Context())\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, \"Could not retrieve images\")\n\t\treturn\n\t}\n\trespondWithJSON(w, http.StatusOK, images)\n}\n\n// GetImage handles GET requests for a specific image.\nfunc (h *ImageHandler) GetImage(w http.ResponseWriter, r *http.Request) {\n\tidStr := chi.URLParam(r, \"id\")\n\tid, err := strconv.Atoi(idStr)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusBadRequest, \"Invalid image ID\")\n\t\treturn\n\t}\n\n\timage, err := h.usecase.GetImage(r.Context(), id)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, \"Could not retrieve image\")\n\t\treturn\n\t}\n\tif image == nil {\n\t\trespondWithError(w, http.StatusNotFound, \"Image not found\")\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusOK, image)\n}\n\n// GetImageSBOMs returns mocked SBOM data for a given image ID.\nfunc (h *ImageHandler) GetImageSBOMs(w http.ResponseWriter, r *http.Request) {\n\t// This is mocked for the MVP. A real implementation would fetch from the db.\n\tmockSBOMs := []map[string]string{\n\t\t{\"format\": \"SPDX\", \"uri\": \"minio://sboms/image-1/sbom.spdx.json\"},\n\t\t{\"format\": \"CycloneDX\", \"uri\": \"minio://sboms/image-1/sbom.cyclonedx.json\"},\n\t}\n\trespondWithJSON(w, http.StatusOK, mockSBOMs)\n}\n\n// GetImageCVEs returns mocked CVE data for a given image ID.\nfunc (h *ImageHandler) GetImageCVEs(w http.ResponseWriter, r *http.Request) {\n\t// This is mocked for the MVP. A real implementation would fetch from the db.\n\tidStr := chi.URLParam(r, \"id\")\n\tvar mockCVEs []map[string]interface{}\n\tif idStr == \"1\" {\n\t\tmockCVEs = []map[string]interface{}{\n\t\t\t{\"cve_id\": \"CVE-2023-12345\", \"severity\": \"High\", \"fix_available\": true},\n\t\t\t{\"cve_id\": \"CVE-2023-67890\", \"severity\": \"Medium\", \"fix_available\": false},\n\t\t}\n\t} else {\n\t\tmockCVEs = []map[string]interface{}{\n\t\t\t{\"cve_id\": \"CVE-2023-54321\", \"severity\": \"Critical\", \"fix_available\": true},\n\t\t}\n\t}\n\trespondWithJSON(w, http.StatusOK, mockCVEs)\n}\n\n// GetImageVerification returns mocked verification data for a given image ID.\nfunc (h *ImageHandler) GetImageVerification(w http.ResponseWriter, r *http.Request) {\n\t// This is mocked for the MVP.\n\tmockVerification := map[string]interface{}{\n\t\t\"signature\": map[string]string{\n\t\t\t\"key_id\":    \"gcpkms://projects/secure-project/locations/global/keyRings/cosign/cryptoKeys/prod-key\",\n\t\t\t\"signature\": \"MEUCIQ...\",\n\t\t},\n\t\t\"rekor_entry\": \"https://rekor.sigstore.dev/api/v1/log/entries/...\",\n\t\t\"attestations\": []map[string]string{\n\t\t\t{\"type\": \"provenance\", \"uri\": \"minio://attestations/image-1/provenance.json\"},\n\t\t\t{\"type\": \"vuln-scan\", \"uri\": \"minio://attestations/image-1/scan-report.json\"},\n\t\t},\n\t}\n\trespondWithJSON(w, http.StatusOK, mockVerification)\n}\n\n// respondWithError is a helper to write a JSON error response.\nfunc respondWithError(w http.ResponseWriter, code int, message string) {\n\trespondWithJSON(w, code, map[string]string{\"error\": message})\n}\n\n// respondWithJSON is a helper to write a JSON response.\nfunc respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {\n\tresponse, _ := json.Marshal(payload)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(code)\n\tw.Write(response)\n}",
  "backend/internal/adapter/handler/http/server.go": "package http\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"secure-image-service/internal/usecase\"\n\t\"time\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n\t\"github.com/rs/zerolog\"\n)\n\n// Server represents the HTTP server.\ntype Server struct {\n\tRouter          *chi.Mux\n\tImageHandler    *ImageHandler\n\tCustomerHandler *CustomerHandler\n\tBuildHandler    *BuildHandler\n\tLogger          zerolog.Logger\n}\n\n// NewServer creates and configures a new Server instance.\nfunc NewServer(\n\timageUsecase *usecase.ImageUsecase,\n\tcustomerUsecase *usecase.CustomerUsecase,\n\tbuildUsecase *usecase.BuildUsecase,\n\tlogger zerolog.ologer,\n) *Server {\n\ts := \u0026Server{\n\t\tRouter:          chi.NewRouter(),\n\t\tImageHandler:    NewImageHandler(imageUsecase),\n\t\tCustomerHandler: NewCustomerHandler(customerUsecase),\n\t\tBuildHandler:    NewBuildHandler(buildUsecase),\n\t\tLogger:          logger,\n\t}\n\ts.setupRoutes()\n\treturn s\n}\n\nfunc (s *Server) setupRoutes() {\n\t// Middleware\n\ts.Router.Use(middleware.RequestID)\n\ts.Router.Use(middleware.RealIP)\n\ts.Router.Use(middleware.Logger)\n\ts.Router.Use(middleware.Recoverer)\n\ts.Router.Use(middleware.Timeout(60 * time.Second))\n\n\t// Health check\n\ts.Router.Get(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\t// API v1 routes\n\ts.Router.Route(\"/v1\", func(r chi.Router) {\n\t\t// Image routes\n\t\tr.Get(\"/images\", s.ImageHandler.ListImages)\n\t\tr.Post(\"/images\", s.ImageHandler.CreateBuild)\n\t\tr.Get(\"/images/{id}\", s.ImageHandler.GetImage)\n\t\tr.Get(\"/images/{id}/sboms\", s.ImageHandler.GetImageSBOMs)\n\t\tr.Get(\"/images/{id}/cves\", s.ImageHandler.GetImageCVEs)\n\t\tr.Get(\"/images/{id}/verification\", s.ImageHandler.GetImageVerification)\n\n\t\t// Customer routes\n\t\tr.Get(\"/customers\", s.CustomerHandler.ListCustomers)\n\t\tr.Get(\"/customers/{namespace}\", s.CustomerHandler.GetCustomer)\n\n\t\t// Build routes\n\t\tr.Post(\"/builds/{buildID}/complete\", s.BuildHandler.CompleteBuild)\n\t})\n}\n\n// ServeHTTP implements the http.Handler interface.\nfunc (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\ts.Router.ServeHTTP(w, r)\n}\n\n// Shutdown is a placeholder for graceful server shutdown.\nfunc (s *Server) Shutdown(ctx context.Context) error {\n\ts.Logger.Info().Msg(\"Server shutting down\")\n\treturn nil\n}",
  "backend/internal/adapter/postgres/build_event_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\ntype pgBuildEventRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewBuildEventRepository(db *pgxpool.Pool) repository.BuildEventRepository {\n\treturn \u0026pgBuildEventRepository{db: db}\n}\n\nfunc (r *pgBuildEventRepository) Create(ctx context.Context, event *domain.BuildEvent) (int, error) {\n\tquery := `INSERT INTO build_events (tenant_namespace, trigger_type, status)\n              VALUES ($1, $2, $3) RETURNING id, created_at, updated_at`\n\terr := r.db.QueryRow(ctx, query, event.TenantNamespace, event.TriggerType, event.Status).Scan(\u0026event.ID, \u0026event.CreatedAt, \u0026event.UpdatedAt)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn event.ID, nil\n}\n\nfunc (r *pgBuildEventRepository) FindByID(ctx context.Context, id int) (*domain.BuildEvent, error) {\n\tquery := `SELECT id, tenant_namespace, image_id, trigger_type, status, created_at, updated_at\n              FROM build_events WHERE id = $1`\n\tevent := \u0026domain.BuildEvent{}\n\terr := r.db.QueryRow(ctx, query, id).Scan(\n\t\t\u0026event.ID, \u0026event.TenantNamespace, \u0026event.ImageID, \u0026event.TriggerType,\n\t\t\u0026event.Status, \u0026event.CreatedAt, \u0026event.UpdatedAt,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn event, nil\n}\n\nfunc (r *pgBuildEventRepository) Update(ctx context.Context, event *domain.BuildEvent) error {\n\tquery := `UPDATE build_events SET image_id = $1, status = $2, updated_at = NOW()\n              WHERE id = $3`\n\t_, err := r.db.Exec(ctx, query, event.ImageID, event.Status, event.ID)\n\treturn err\n}\n",
  "backend/internal/adapter/postgres/customer_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype pgCustomerRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewCustomerRepository(db *pgxpool.Pool) repository.CustomerRepository {\n\treturn \u0026pgCustomerRepository{db: db}\n}\n\nfunc (r *pgCustomerRepository) FindAll(ctx context.Context) ([]*domain.Customer, error) {\n\trows, err := r.db.Query(ctx, \"SELECT namespace, name, contact_info, sla_tier, created_at, updated_at FROM customers ORDER BY name\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tcustomers, err := pgx.CollectRows(rows, pgx.RowToAddrOfStructByPos[domain.Customer])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn customers, nil\n}\n\nfunc (r *pgCustomerRepository) FindByNamespace(ctx context.Context, namespace string) (*domain.Customer, error) {\n\trow := r.db.QueryRow(ctx, \"SELECT namespace, name, contact_info, sla_tier, created_at, updated_at FROM customers WHERE namespace = $1\", namespace)\n\n\tcustomer, err := pgx.RowToAddrOfStructByPos[domain.Customer](row)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil // Not found is not an error\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn customer, nil\n}\n",
  "backend/internal/adapter/postgres/cve_finding_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\ntype pgCVEFindingRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewCVEFindingRepository(db *pgxpool.Pool) repository.CVEFindingRepository {\n\treturn \u0026pgCVEFindingRepository{db: db}\n}\n\nfunc (r *pgCVEFindingRepository) CreateBatch(ctx context.Context, cves []*domain.CVEFinding) error {\n\tif len(cves) == 0 {\n\t\treturn nil\n\t}\n\n\tbatch := \u0026pgx.Batch{}\n\tquery := `INSERT INTO cve_findings (image_id, cve_id, severity, description, fix_available)\n              VALUES ($1, $2, $3, $4, $5)`\n\n\tfor _, cve := range cves {\n\t\tbatch.Queue(query, cve.ImageID, cve.CVEID, cve.Severity, cve.Description, cve.FixAvailable)\n\t}\n\n\tbr := r.db.SendBatch(ctx, batch)\n\tdefer br.Close()\n\n\tfor i := 0; i \u003c len(cves); i++ {\n\t\tif _, err := br.Exec(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n",
  "backend/internal/adapter/postgres/db.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\nfunc NewConnection(ctx context.Context, connString string) (*pgxpool.Pool, error) {\n\tpool, err := pgxpool.New(ctx, connString)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create connection pool: %w\", err)\n\t}\n\n\tif err := pool.Ping(ctx); err != nil {\n\t\tpool.Close()\n\t\treturn nil, fmt.Errorf(\"unable to ping database: %w\", err)\n\t}\n\n\treturn pool, nil\n}\n",
  "backend/internal/adapter/postgres/image_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\t\"github.com/lib/pq\"\n)\n\ntype pgImageRepository struct {\n\tdb *pgxpool.Pool\n}\n\n// NewImageRepository creates a new PostgreSQL-backed ImageRepository.\nfunc NewImageRepository(db *pgxpool.Pool) repository.ImageRepository {\n\treturn \u0026pgImageRepository{db: db}\n}\n\n// FindAll retrieves all images from the database.\nfunc (r *pgImageRepository) FindAll(ctx context.Context) ([]*domain.Image, error) {\n\tquery := `SELECT id, tenant_namespace, digest, tags, slsa_level, created_at, updated_at FROM images ORDER BY created_at DESC`\n\trows, err := r.db.Query(ctx, query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar images []*domain.Image\n\tfor rows.Next() {\n\t\tvar image domain.Image\n\t\tvar tags pq.StringArray\n\t\tif err := rows.Scan(\u0026image.ID, \u0026image.TenantNamespace, \u0026image.Digest, \u0026tags, \u0026image.SLSALevel, \u0026image.CreatedAt, \u0026image.UpdatedAt); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\timage.Tags = tags\n\t\timages = append(images, \u0026image)\n\t}\n\n\treturn images, nil\n}\n\n// FindByID retrieves a single image by its ID.\nfunc (r *pgImageRepository) FindByID(ctx context.Context, id int) (*domain.Image, error) {\n\tquery := `SELECT id, tenant_namespace, digest, tags, slsa_level, created_at, updated_at FROM images WHERE id = $1`\n\tvar image domain.Image\n\tvar tags pq.StringArray\n\terr := r.db.QueryRow(ctx, query, id).Scan(\u0026image.ID, \u0026image.TenantNamespace, \u0026image.Digest, \u0026tags, \u0026image.SLSALevel, \u0026image.CreatedAt, \u0026image.UpdatedAt)\n\tif err != nil {\n\t\tif err == pgx.ErrNoRows {\n\t\t\treturn nil, nil // Not found is not an error\n\t\t}\n\t\treturn nil, err\n\t}\n\timage.Tags = tags\n\treturn \u0026image, nil\n}\n\nfunc (r *pgImageRepository) Create(ctx context.Context, image *domain.Image) (int, error) {\n\tquery := `INSERT INTO images (tenant_namespace, digest, tags, slsa_level)\n              VALUES ($1, $2, $3, $4) RETURNING id, created_at, updated_at`\n\terr := r.db.QueryRow(ctx, query, image.TenantNamespace, image.Digest, pq.Array(image.Tags), image.SLSALevel).Scan(\u0026image.ID, \u0026image.CreatedAt, \u0026image.UpdatedAt)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn image.ID, nil\n}",
  "backend/internal/adapter/postgres/sbom_record_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\ntype pgSBOMRecordRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewSBOMRecordRepository(db *pgxpool.Pool) repository.SBOMRecordRepository {\n\treturn \u0026pgSBOMRecordRepository{db: db}\n}\n\nfunc (r *pgSBOMRecordRepository) Create(ctx context.Context, sbom *domain.SBOMRecord) error {\n\tquery := `INSERT INTO sbom_records (image_id, format, uri) VALUES ($1, $2, $3)`\n\t_, err := r.db.Exec(ctx, query, sbom.ImageID, sbom.Format, sbom.URI)\n\treturn err\n}\n",
  "backend/internal/adapter/simulator/orchestrator.go": "package simulator\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"secure-image-service/internal/domain\"\n)\n\ntype BuildOrchestrator interface {\n\tTriggerBuild(ctx context.Context, event *domain.BuildEvent) error\n}\n\ntype MockBuildOrchestrator struct{}\n\nfunc NewMockBuildOrchestrator() BuildOrchestrator {\n\treturn \u0026MockBuildOrchestrator{}\n}\n\nfunc (m *MockBuildOrchestrator) TriggerBuild(ctx context.Context, event *domain.BuildEvent) error {\n\tlog.Printf(\"SIMULATOR: Triggering build for event ID %d (tenant: %s)\", event.ID, event.TenantNamespace)\n\t// In a real system, this would call a CI/CD system (e.g., Jenkins, GitLab CI).\n\t// For this MVP, we just log the action. The build completion is simulated\n\t// by a separate API call to POST /v1/builds/{build_id}/complete.\n\treturn nil\n}\n",
  "backend/internal/domain/build_event.go": "package domain\n\nimport \"time\"\n\ntype BuildEvent struct {\n\tID              int       `json:\"id\"`\n\tTenantNamespace string    `json:\"tenant_namespace\"`\n\tImageID         *int      `json:\"image_id,omitempty\"` // Pointer to allow null\n\tTriggerType     string    `json:\"trigger_type\"`\n\tStatus          string    `json:\"status\"`\n\tCreatedAt       time.Time `json:\"created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\"`\n}\n",
  "backend/internal/domain/customer.go": "package domain\n\nimport \"time\"\n\ntype Customer struct {\n\tNamespace    string    `json:\"namespace\"`\n\tName         string    `json:\"name\"`\n\tContactInfo  string    `json:\"contact_info\"`\n\tSLATier      string    `json:\"sla_tier\"`\n\tCreatedAt    time.Time `json:\"created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\"`\n}\n",
  "backend/internal/domain/cve_finding.go": "package domain\n\nimport \"time\"\n\ntype CVEFinding struct {\n\tID           int       `json:\"id\"`\n\tImageID      int       `json:\"image_id\"`\n\tCVEID        string    `json:\"cve_id\"`\n\tSeverity     string    `json:\"severity\"`\n\tDescription  string    `json:\"description\"`\n\tFixAvailable bool      `json:\"fix_available\"`\n\tCreatedAt    time.Time `json:\"created_at\"`\n}\n",
  "backend/internal/domain/image.go": "package domain\n\nimport (\n\t\"time\"\n)\n\ntype Image struct {\n\tID              int       `json:\"id\"`\n\tTenantNamespace string    `json:\"tenant_namespace\"`\n\tDigest          string    `json:\"digest\"`\n\tTags            []string  `json:\"tags\"`\n\tSLSALevel       int       `json:\"slsa_level\"`\n\tCreatedAt       time.Time `json:\"created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\"`\n}\n",
  "backend/internal/domain/sbom_record.go": "package domain\n\nimport \"time\"\n\ntype SBOMRecord struct {\n\tID        int       `json:\"id\"`\n\tImageID   int       `json:\"image_id\"`\n\tFormat    string    `json:\"format\"`\n\tURI       string    `json:\"uri\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n}\n",
  "backend/internal/repository/build_event.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n)\n\ntype BuildEventRepository interface {\n\tCreate(ctx context.Context, event *domain.BuildEvent) (int, error)\n\tFindByID(ctx context.Context, id int) (*domain.BuildEvent, error)\n\tUpdate(ctx context.Context, event *domain.BuildEvent) error\n}\n",
  "backend/internal/repository/customer.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n)\n\ntype CustomerRepository interface {\n\tFindAll(ctx context.Context) ([]*domain.Customer, error)\n\tFindByNamespace(ctx context.Context, namespace string) (*domain.Customer, error)\n}\n",
  "backend/internal/repository/cve_finding.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n)\n\ntype CVEFindingRepository interface {\n\tCreateBatch(ctx context.Context, cves []*domain.CVEFinding) error\n}\n",
  "backend/internal/repository/image.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n)\n\n// ImageRepository defines the interface for accessing image data.\ntype ImageRepository interface {\n\tFindAll(ctx context.Context) ([]*domain.Image, error)\n\tFindByID(ctx context.Context, id int) (*domain.Image, error)\n\tCreate(ctx context.Context, image *domain.Image) (int, error)\n}",
  "backend/internal/repository/sbom_record.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n)\n\ntype SBOMRecordRepository interface {\n\tCreate(ctx context.Context, sbom *domain.SBOMRecord) error\n}\n",
  "backend/internal/usecase/build_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\ntype BuildCompletionRequest struct {\n\tImageDigest string            `json:\"image_digest\"`\n\tTags        []string          `json:\"tags\"`\n\tSLSALevel   int               `json:\"slsa_level\"`\n\tSBOMs       []SBOMInput       `json:\"sboms\"`\n\tCVEs        []CVEFindingInput `json:\"cves\"`\n}\n\ntype SBOMInput struct {\n\tFormat string `json:\"format\"`\n\tURI    string `json:\"uri\"`\n}\n\ntype CVEFindingInput struct {\n\tCVEID        string `json:\"cve_id\"`\n\tSeverity     string `json:\"severity\"`\n\tDescription  string `json:\"description\"`\n\tFixAvailable bool   `json:\"fix_available\"`\n}\n\ntype BuildUsecase struct {\n\tbuildRepo repository.BuildEventRepository\n\timageRepo repository.ImageRepository\n\tsbomRepo  repository.SBOMRecordRepository\n\tcveRepo   repository.CVEFindingRepository\n}\n\nfunc NewBuildUsecase(\n\tbuildRepo repository.BuildEventRepository,\n\timageRepo repository.ImageRepository,\n\tsbomRepo repository.SBOMRecordRepository,\n\tcveRepo repository.CVEFindingRepository,\n) *BuildUsecase {\n\treturn \u0026BuildUsecase{\n\t\tbuildRepo: buildRepo,\n\t\timageRepo: imageRepo,\n\t\tsbomRepo:  sbomRepo,\n\t\tcveRepo:   cveRepo,\n\t}\n}\n\nfunc (uc *BuildUsecase) CompleteBuild(ctx context.Context, buildID int, req BuildCompletionRequest) (*domain.Image, error) {\n\t// 1. Find the build event and validate its state\n\tbuildEvent, err := uc.buildRepo.FindByID(ctx, buildID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"build event not found: %w\", err)\n\t}\n\tif buildEvent.Status != \"pending\" {\n\t\treturn nil, fmt.Errorf(\"build event %d is not in 'pending' state, current state: %s\", buildID, buildEvent.Status)\n\t}\n\n\t// 2. Create the new image record\n\tnewImage := \u0026domain.Image{\n\t\tTenantNamespace: buildEvent.TenantNamespace,\n\t\tDigest:          req.ImageDigest,\n\t\tTags:            req.Tags,\n\t\tSLSALevel:       req.SLSALevel,\n\t}\n\timageID, err := uc.imageRepo.Create(ctx, newImage)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create image record: %w\", err)\n\t}\n\tnewImage.ID = imageID\n\n\t// 3. Create SBOM records\n\tfor _, sbomInput := range req.SBOMs {\n\t\tsbomRecord := \u0026domain.SBOMRecord{\n\t\t\tImageID: imageID,\n\t\t\tFormat:  sbomInput.Format,\n\t\t\tURI:     sbomInput.URI,\n\t\t}\n\t\tif err := uc.sbomRepo.Create(ctx, sbomRecord); err != nil {\n\t\t\t// In a real system, we'd want transactional behavior here\n\t\t\treturn nil, fmt.Errorf(\"failed to create sbom record: %w\", err)\n\t\t}\n\t}\n\n\t// 4. Create CVE finding records\n\tvar cveFindings []*domain.CVEFinding\n\tfor _, cveInput := range req.CVEs {\n\t\tcveFindings = append(cveFindings, \u0026domain.CVEFinding{\n\t\t\tImageID:      imageID,\n\t\t\tCVEID:        cveInput.CVEID,\n\t\t\tSeverity:     cveInput.Severity,\n\t\t\tDescription:  cveInput.Description,\n\t\t\tFixAvailable: cveInput.FixAvailable,\n\t\t})\n\t}\n\tif err := uc.cveRepo.CreateBatch(ctx, cveFindings); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create cve findings: %w\", err)\n\t}\n\n\t// 5. Update the build event with the new image_id and set status to 'completed'\n\tbuildEvent.ImageID = \u0026imageID\n\tbuildEvent.Status = \"completed\"\n\tif err := uc.buildRepo.Update(ctx, buildEvent); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to update build event: %w\", err)\n\t}\n\n\treturn newImage, nil\n}\n",
  "backend/internal/usecase/customer_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\ntype CustomerUsecase struct {\n\trepo repository.CustomerRepository\n}\n\nfunc NewCustomerUsecase(repo repository.CustomerRepository) *CustomerUsecase {\n\treturn \u0026CustomerUsecase{repo: repo}\n}\n\nfunc (uc *CustomerUsecase) ListCustomers(ctx context.Context) ([]*domain.Customer, error) {\n\treturn uc.repo.FindAll(ctx)\n}\n\nfunc (uc *CustomerUsecase) GetCustomer(ctx context.Context, namespace string) (*domain.Customer, error) {\n\treturn uc.repo.FindByNamespace(ctx, namespace)\n}\n",
  "backend/internal/usecase/image_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/adapter/simulator\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\n// ImageUsecase handles business logic for images.\ntype ImageUsecase struct {\n\trepo         repository.ImageRepository\n\tbuildRepo    repository.BuildEventRepository\n\torchestrator simulator.BuildOrchestrator\n}\n\n// NewImageUsecase creates a new ImageUsecase.\nfunc NewImageUsecase(repo repository.ImageRepository, buildRepo repository.BuildEventRepository, orchestrator simulator.BuildOrchestrator) *ImageUsecase {\n\treturn \u0026ImageUsecase{\n\t\trepo:         repo,\n\t\tbuildRepo:    buildRepo,\n\t\torchestrator: orchestrator,\n\t}\n}\n\n// ListImages retrieves all images.\nfunc (uc *ImageUsecase) ListImages(ctx context.Context) ([]*domain.Image, error) {\n\treturn uc.repo.FindAll(ctx)\n}\n\n// GetImage retrieves a single image by its ID.\nfunc (uc *ImageUsecase) GetImage(ctx context.Context, id int) (*domain.Image, error) {\n\treturn uc.repo.FindByID(ctx, id)\n}\n\n// CreateBuild creates a build event and triggers a simulated build.\nfunc (uc *ImageUsecase) CreateBuild(ctx context.Context, tenantNamespace, triggerType string) (*domain.BuildEvent, error) {\n\t// 1. Create a build event record in the database\n\tevent := \u0026domain.BuildEvent{\n\t\tTenantNamespace: tenantNamespace,\n\t\tTriggerType:     triggerType,\n\t\tStatus:          \"pending\",\n\t}\n\t_, err := uc.buildRepo.Create(ctx, event)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// 2. Trigger the build orchestrator\n\tif err := uc.orchestrator.TriggerBuild(ctx, event); err != nil {\n\t\t// In a real system, you might want to mark the build event as failed here.\n\t\treturn nil, err\n\t}\n\n\treturn event, nil\n}",
  "backend/pkg/config/config.go": "package config\n\nimport (\n\t\"os\"\n\t\"strconv\"\n)\n\ntype Config struct {\n\tDatabaseURL string\n\tAPIPort     string\n}\n\nfunc Load() (*Config, error) {\n\tport := os.Getenv(\"API_PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\n\t// Validate port is a number\n\tif _, err := strconv.Atoi(port); err != nil {\n\t\tport = \"8080\"\n\t}\n\n\treturn \u0026Config{\n\t\tDatabaseURL: os.Getenv(\"DATABASE_URL\"),\n\t\tAPIPort:     port,\n\t}, nil\n}\n",
  "backend/pkg/logger/logger.go": "package logger\n\nimport (\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog\"\n)\n\nfunc New() zerolog.Logger {\n\treturn zerolog.New(zerolog.ConsoleWriter{Out: os.Stderr, TimeFormat: time.RFC3339}).\n\t\tLevel(zerolog.TraceLevel).\n\t\tWith().\n\t\tTimestamp().\n\t\tLogger()\n}\n",
  "deployments/docker-compose.yml": "version: '3.8'\n\nservices:\n  db:\n    image: postgres:14-alpine\n    container_name: ssc-db\n    environment:\n      POSTGRES_DB: ${POSTGRES_DB}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./seed/init.sql:/docker-entrypoint-initdb.d/init.sql\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n\n  minio:\n    image: minio/minio:latest\n    container_name: ssc-minio\n    ports:\n      - \"9000:9000\"\n      - \"9001:9001\"\n    environment:\n      MINIO_ROOT_USER: ${MINIO_ACCESS_KEY}\n      MINIO_ROOT_PASSWORD: ${MINIO_SECRET_KEY}\n    command: server /data --console-address \":9001\"\n    volumes:\n      - minio_data:/data\n\n  backend:\n    build:\n      context: ../backend\n      dockerfile: Dockerfile\n    container_name: ssc-backend\n    ports:\n      - \"${API_PORT}:${API_PORT}\"\n    depends_on:\n      db:\n        condition: service_healthy\n    environment:\n      - DATABASE_URL=${DATABASE_URL}\n      - API_PORT=${API_PORT}\n    env_file:\n      - ../.env\n\n  frontend:\n    image: nginx:alpine\n    container_name: ssc-frontend\n    ports:\n      - \"80:80\"\n    volumes:\n      - ../frontend:/usr/share/nginx/html\n    depends_on:\n      - backend\n\nvolumes:\n  postgres_data:\n  minio_data:\n",
  "deployments/seed/init.sql": "-- Enable extensions\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n-- Create customers table to represent tenants\nCREATE TABLE IF NOT EXISTS customers (\n    namespace VARCHAR(255) PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    contact_info VARCHAR(255),\n    sla_tier VARCHAR(50) NOT NULL DEFAULT 'standard',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\n-- Create images table\nCREATE TABLE IF NOT EXISTS images (\n    id SERIAL PRIMARY KEY,\n    tenant_namespace VARCHAR(255) NOT NULL REFERENCES customers(namespace) ON DELETE CASCADE,\n    digest VARCHAR(255) UNIQUE NOT NULL,\n    tags TEXT[],\n    slsa_level INT,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\nCREATE INDEX IF NOT EXISTS idx_images_tenant_namespace ON images(tenant_namespace);\n\n-- Build Events Table\nCREATE TABLE IF NOT EXISTS build_events (\n    id SERIAL PRIMARY KEY,\n    tenant_namespace VARCHAR(255) NOT NULL REFERENCES customers(namespace) ON DELETE CASCADE,\n    image_id INT REFERENCES images(id) ON DELETE SET NULL, -- Allow image_id to be null if image is deleted\n    trigger_type VARCHAR(50) NOT NULL,\n    status VARCHAR(50) NOT NULL DEFAULT 'pending',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\nCREATE INDEX IF NOT EXISTS idx_build_events_tenant_namespace ON build_events(tenant_namespace);\nCREATE INDEX IF NOT EXISTS idx_build_events_status ON build_events(status);\n\n-- Table for SBOM records\nCREATE TABLE IF NOT EXISTS sbom_records (\n    id SERIAL PRIMARY KEY,\n    image_id INT NOT NULL REFERENCES images(id) ON DELETE CASCADE,\n    format VARCHAR(50) NOT NULL, -- e.g., 'SPDX', 'CycloneDX'\n    uri VARCHAR(255) NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\nCREATE INDEX IF NOT EXISTS idx_sbom_records_image_id ON sbom_records(image_id);\n\n-- Table for CVE findings\nCREATE TABLE IF NOT EXISTS cve_findings (\n    id SERIAL PRIMARY KEY,\n    image_id INT NOT NULL REFERENCES images(id) ON DELETE CASCADE,\n    cve_id VARCHAR(50) NOT NULL,\n    severity VARCHAR(50) NOT NULL, -- e.g., 'Critical', 'High', 'Medium', 'Low'\n    description TEXT,\n    fix_available BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\nCREATE INDEX IF NOT EXISTS idx_cve_findings_image_id ON cve_findings(image_id);\n\n-- Table for attestations\nCREATE TABLE IF NOT EXISTS attestations (\n    id SERIAL PRIMARY KEY,\n    image_id INT NOT NULL REFERENCES images(id) ON DELETE CASCADE,\n    type VARCHAR(100) NOT NULL, -- e.g., 'provenance', 'slsa'\n    uri VARCHAR(255) NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\nCREATE INDEX IF NOT EXISTS idx_attestations_image_id ON attestations(image_id);\n\n\n-- Seed data\nTRUNCATE customers, images, build_events, sbom_records, cve_findings, attestations RESTART IDENTITY CASCADE;\n\nINSERT INTO customers (namespace, name, contact_info, sla_tier) VALUES\n('acme-corp', 'ACME Corporation', 'contact@acme.com', 'enterprise'),\n('startup-x', 'Startup X', 'devops@startupx.io', 'standard');\n\nINSERT INTO images (tenant_namespace, digest, tags, slsa_level) VALUES\n('acme-corp', 'sha256:c3d3e4f5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3', ARRAY['latest', '1.2.3'], 3),\n('startup-x', 'sha256:d4e4f5g6h7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c4d5', ARRAY['latest'], 1);\n\n-- Seed SBOMs\nINSERT INTO sbom_records (image_id, format, uri) VALUES\n(1, 'SPDX', 'minio://sboms/acme-corp/c3d3e4f5.../sbom.spdx.json'),\n(1, 'CycloneDX', 'minio://sboms/acme-corp/c3d3e4f5.../sbom.cyclonedx.json'),\n(2, 'SPDX', 'minio://sboms/startup-x/d4e4f5g6.../sbom.spdx.json');\n\n-- Seed CVEs\nINSERT INTO cve_findings (image_id, cve_id, severity, description, fix_available) VALUES\n(1, 'CVE-2023-12345', 'High', 'Remote code execution vulnerability in libfoo', true),\n(1, 'CVE-2023-67890', 'Medium', 'Denial of service in bar-utils', false),\n(2, 'CVE-2023-54321', 'Critical', 'SQL injection in database driver', true);\n\n-- Seed Attestations\nINSERT INTO attestations (image_id, type, uri) VALUES\n(1, 'provenance', 'minio://attestations/acme-corp/c3d3e4f5.../provenance.json'),\n(1, 'vuln-scan', 'minio://attestations/acme-corp/c3d3e4f5.../scan-report.json');\n\n-- Seed Build Events\nINSERT INTO build_events (tenant_namespace, image_id, trigger_type, status) VALUES\n('acme-corp', 1, 'manual', 'completed'),\n('startup-x', 2, 'webhook', 'completed');",
  "frontend/css/style.css": "body {\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n    line-height: 1.6;\n    background-color: #f4f7f9;\n    color: #333;\n    margin: 0;\n    padding: 0;\n}\n\nheader {\n    background-color: #2c3e50;\n    color: #ecf0f1;\n    padding: 1rem 2rem;\n    margin-bottom: 2rem;\n}\n\nheader h1 {\n    margin: 0;\n    font-size: 1.5rem;\n}\n\nheader h1 a {\n    color: #ecf0f1;\n    text-decoration: none;\n}\n\nmain {\n    max-width: 1200px;\n    margin: 0 auto;\n    padding: 0 2rem;\n}\n\n.card {\n    background: #fff;\n    padding: 1.5rem;\n    border-radius: 8px;\n    box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n    margin-bottom: 1rem;\n}\n\n.card h2 {\n    margin-top: 0;\n    color: #34495e;\n    border-bottom: 2px solid #e0e0e0;\n    padding-bottom: 0.5rem;\n}\n\n.image-table {\n    width: 100%;\n    border-collapse: collapse;\n}\n\n.image-table th, .image-table td {\n    padding: 0.75rem;\n    text-align: left;\n    border-bottom: 1px solid #ddd;\n}\n\n.image-table th {\n    background-color: #f2f2f2;\n    font-weight: 600;\n}\n\n.image-table tbody tr:hover {\n    background-color: #f9f9f9;\n}\n\n.btn {\n    display: inline-block;\n    padding: 0.5rem 1rem;\n    background-color: #3498db;\n    color: #fff;\n    text-decoration: none;\n    border-radius: 4px;\n    border: none;\n    cursor: pointer;\n    font-size: 0.9rem;\n}\n\n.btn:hover {\n    background-color: #2980b9;\n}\n\n.back-link {\n    display: inline-block;\n    margin-bottom: 1.5rem;\n    color: #3498db;\n    text-decoration: none;\n    font-weight: 600;\n}\n\n.back-link:hover {\n    text-decoration: underline;\n}\n\n.grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 1.5rem;\n}\n\n.detail-list {\n    list-style: none;\n    padding: 0;\n}\n\n.detail-list li {\n    padding: 0.5rem 0;\n    border-bottom: 1px solid #eee;\n}\n\n.detail-list li:last-child {\n    border-bottom: none;\n}\n\n.detail-list strong {\n    display: inline-block;\n    width: 120px;\n    color: #555;\n}\n\n.tag {\n    display: inline-block;\n    background-color: #e0e0e0;\n    color: #555;\n    padding: 0.2rem 0.6rem;\n    border-radius: 12px;\n    font-size: 0.8rem;\n    margin-right: 0.3rem;\n}\n\n.severity-Critical { color: #c0392b; font-weight: bold; }\n.severity-High { color: #e67e22; font-weight: bold; }\n.severity-Medium { color: #f1c40f; }\n.severity-Low { color: #2ecc71; }",
  "frontend/index.html": "\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eSecure Software Supply Chain MVP\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"css/style.css\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cheader\u003e\n        \u003ch1\u003e\u003ca href=\"#\"\u003eSecure Software Supply Chain MVP\u003c/a\u003e\u003c/h1\u003e\n    \u003c/header\u003e\n    \u003cmain id=\"app\"\u003e\n        \u003cp\u003eLoading...\u003c/p\u003e\n    \u003c/main\u003e\n    \u003cscript type=\"module\" src=\"js/main.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e",
  "frontend/js/api.js": "const BASE_URL = '/v1';\n\nasync function fetchJSON(url, options = {}) {\n    try {\n        const response = await fetch(url, options);\n        if (!response.ok) {\n            const errorData = await response.json().catch(() =\u003e ({ message: response.statusText }));\n            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);\n        }\n        return await response.json();\n    } catch (error) {\n        console.error('API call failed:', error);\n        throw error;\n    }\n}\n\nexport const apiClient = {\n    getImages: () =\u003e fetchJSON(`${BASE_URL}/images`),\n    getImage: (id) =\u003e fetchJSON(`${BASE_URL}/images/${id}`),\n    getImageSBOMs: (id) =\u003e fetchJSON(`${BASE_URL}/images/${id}/sbom`),\n    getImageCVEs: (id) =\u003e fetchJSON(`${BASE_URL}/images/${id}/cves`),\n    getImageVerification: (id) =\u003e fetchJSON(`${BASE_URL}/images/${id}/verify`),\n};\n",
  "frontend/js/components/imageDetail.js": "function renderCVEs(cves) {\n    if (!cves || cves.length === 0) {\n        return '\u003cp\u003eNo CVEs found for this image.\u003c/p\u003e';\n    }\n    return `\n        \u003cul class=\"detail-list\"\u003e\n            ${cves.map(cve =\u003e `\n                \u003cli\u003e\n                    \u003cstrong class=\"severity-${cve.severity}\"\u003e${cve.cve_id}\u003c/strong\u003e\n                    \u003cspan\u003e(${cve.severity}) - ${cve.fix_available ? 'Fix Available' : 'No Fix'}\u003c/span\u003e\n                \u003c/li\u003e\n            `).join('')}\n        \u003c/ul\u003e\n    `;\n}\n\nfunction renderSBOMs(sboms) {\n    if (!sboms || sboms.length === 0) {\n        return '\u003cp\u003eNo SBOMs found.\u003c/p\u003e';\n    }\n    return `\n        \u003cul class=\"detail-list\"\u003e\n            ${sboms.map(sbom =\u003e `\n                \u003cli\u003e\n                    \u003cstrong\u003e${sbom.format}\u003c/strong\u003e\n                    \u003ca href=\"${sbom.uri}\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e${sbom.uri}\u003c/a\u003e\n                \u003c/li\u003e\n            `).join('')}\n        \u003c/ul\u003e\n    `;\n}\n\nfunction renderVerification(verification) {\n    return `\n        \u003cul class=\"detail-list\"\u003e\n            \u003cli\u003e\u003cstrong\u003eSignature Key ID\u003c/strong\u003e \u003ccode\u003e${verification.signature.keyId}\u003c/code\u003e\u003c/li\u003e\n            \u003cli\u003e\u003cstrong\u003eRekor Entry\u003c/strong\u003e \u003ca href=\"${verification.rekorEntry}\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eView Entry\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n        \u003ch4\u003eAttestations\u003c/h4\u003e\n        \u003cul class=\"detail-list\"\u003e\n            ${verification.attestations.map(att =\u003e `\n                \u003cli\u003e\n                    \u003cstrong\u003e${att.type}\u003c/strong\u003e\n                    \u003ca href=\"${att.uri}\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e${att.uri}\u003c/a\u003e\n                \u003c/li\u003e\n            `).join('')}\n        \u003c/ul\u003e\n    `;\n}\n\nexport function renderImageDetail({ image, sboms, cves, verification }) {\n    return `\n        \u003ca href=\"#\" class=\"back-link\"\u003e\u0026larr; Back to Image List\u003c/a\u003e\n        \u003cdiv class=\"card\"\u003e\n            \u003ch2\u003eImage Details: \u003ccode style=\"font-size: 1.1rem;\"\u003e${image.digest.substring(0, 20)}...\u003c/code\u003e\u003c/h2\u003e\n            \u003cul class=\"detail-list\"\u003e\n                \u003cli\u003e\u003cstrong\u003eID\u003c/strong\u003e ${image.id}\u003c/li\u003e\n                \u003cli\u003e\u003cstrong\u003eTenant\u003c/strong\u003e ${image.tenant_namespace}\u003c/li\u003e\n                \u003cli\u003e\u003cstrong\u003eDigest\u003c/strong\u003e \u003ccode\u003e${image.digest}\u003c/code\u003e\u003c/li\u003e\n                \u003cli\u003e\u003cstrong\u003eTags\u003c/strong\u003e ${image.tags ? image.tags.map(tag =\u003e `\u003cspan class=\"tag\"\u003e${tag}\u003c/span\u003e`).join(' ') : 'None'}\u003c/li\u003e\n                \u003cli\u003e\u003cstrong\u003eSLSA Level\u003c/strong\u003e ${image.slsa_level}\u003c/li\u003e\n                \u003cli\u003e\u003cstrong\u003eCreated At\u003c/strong\u003e ${new Date(image.created_at).toLocaleString()}\u003c/li\u003e\n            \u003c/ul\u003e\n        \u003c/div\u003e\n\n        \u003cdiv class=\"grid\"\u003e\n            \u003cdiv class=\"card\"\u003e\n                \u003ch2\u003eCVE Findings\u003c/h2\u003e\n                ${renderCVEs(cves)}\n            \u003c/div\u003e\n            \u003cdiv class=\"card\"\u003e\n                \u003ch2\u003eSBOMs (Software Bill of Materials)\u003c/h2\u003e\n                ${renderSBOMs(sboms)}\n            \u003c/div\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"card\"\u003e\n            \u003ch2\u003eVerification \u0026 Attestations\u003c/h2\u003e\n            ${renderVerification(verification)}\n        \u003c/div\u003e\n    `;\n}\n```",
  "frontend/js/components/imageTable.js": "export function renderImageTable(images) {\n    if (!images || images.length === 0) {\n        return '\u003cdiv class=\"card\"\u003e\u003cp\u003eNo images found.\u003c/p\u003e\u003c/div\u003e';\n    }\n\n    const rows = images.map(image =\u003e `\n        \u003ctr\u003e\n            \u003ctd\u003e${image.id}\u003c/td\u003e\n            \u003ctd\u003e${image.tenant_namespace}\u003c/td\u003e\n            \u003ctd\u003e\u003ccode title=\"${image.digest}\"\u003e${image.digest.substring(0, 20)}...\u003c/code\u003e\u003c/td\u003e\n            \u003ctd\u003e${image.tags ? image.tags.map(tag =\u003e `\u003cspan class=\"tag\"\u003e${tag}\u003c/span\u003e`).join(' ') : ''}\u003c/td\u003e\n            \u003ctd\u003eSLSA ${image.slsa_level}\u003c/td\u003e\n            \u003ctd\u003e\u003ca href=\"#/images/${image.id}\" class=\"btn\"\u003eView Details\u003c/a\u003e\u003c/td\u003e\n        \u003c/tr\u003e\n    `).join('');\n\n    return `\n        \u003cdiv class=\"card\"\u003e\n            \u003ch2\u003eImage Explorer\u003c/h2\u003e\n            \u003ctable class=\"image-table\"\u003e\n                \u003cthead\u003e\n                    \u003ctr\u003e\n                        \u003cth\u003eID\u003c/th\u003e\n                        \u003cth\u003eTenant\u003c/th\u003e\n                        \u003cth\u003eDigest\u003c/th\u003e\n                        \u003cth\u003eTags\u003c/th\u003e\n                        \u003cth\u003eSLSA Level\u003c/th\u003e\n                        \u003cth\u003eActions\u003c/th\u003e\n                    \u003c/tr\u003e\n                \u003c/thead\u003e\n                \u003ctbody\u003e\n                    ${rows}\n                \u003c/tbody\u003e\n            \u003c/table\u003e\n        \u003c/div\u003e\n    `;\n}\n",
  "frontend/js/main.js": "import { apiClient } from './api.js';\nimport { renderImageTable } from './components/imageTable.js';\nimport { renderImageDetail } from './components/imageDetail.js';\n\nconst app = document.getElementById('app');\n\nconst showLoading = () =\u003e {\n    app.innerHTML = '\u003cp\u003eLoading...\u003c/p\u003e';\n};\n\nconst showError = (message) =\u003e {\n    app.innerHTML = `\u003cp style=\"color: red;\"\u003eError: ${message}\u003c/p\u003e`;\n};\n\nconst showImageListView = async () =\u003e {\n    showLoading();\n    try {\n        const images = await apiClient.getImages();\n        app.innerHTML = renderImageTable(images);\n    } catch (error) {\n        showError(error.message);\n    }\n};\n\nconst showImageDetailView = async (id) =\u003e {\n    showLoading();\n    try {\n        const [image, sboms, cves, verification] = await Promise.all([\n            apiClient.getImage(id),\n            apiClient.getImageSBOMs(id),\n            apiClient.getImageCVEs(id),\n            apiClient.getImageVerification(id),\n        ]);\n        app.innerHTML = renderImageDetail({ image, sboms, cves, verification });\n    } catch (error) {\n        showError(error.message);\n    }\n};\n\nconst router = () =\u003e {\n    const hash = window.location.hash;\n    const match = hash.match(/^#\\/images\\/(\\d+)$/);\n\n    if (match) {\n        const imageId = match[1];\n        showImageDetailView(imageId);\n    } else {\n        showImageListView();\n    }\n};\n\nwindow.addEventListener('hashchange', router);\nwindow.addEventListener('DOMContentLoaded', router);"
}