{
  ".env.example": "# API Server Configuration\nAPI_PORT=8080\n\n# PostgreSQL Database Configuration\nPOSTGRES_USER=user\nPOSTGRES_PASSWORD=password\nPOSTGRES_DB=secure_supply_chain\nDATABASE_URL=postgres://user:password@db:5432/secure_supply_chain?sslmode=disable\n\n# MinIO Configuration (placeholders for now)\nMINIO_ENDPOINT=minio:9000\nMINIO_ACCESS_KEY=minioadmin\nMINIO_SECRET_KEY=minioadmin\nMINIO_USE_SSL=false\n",
  ".github/workflows/ci.yml": "name: CI\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    branches: [ \"main\" ]\n\njobs:\n  lint:\n    name: Lint\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-go@v5\n        with:\n          go-version: '1.21'\n      - name: golangci-lint\n        uses: golangci/golangci-lint-action@v4\n        with:\n          version: v1.55.2\n          working-directory: backend\n\n  build:\n    name: Build Docker Image\n    runs-on: ubuntu-latest\n    needs: lint\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build the Docker image\n        run: docker build --tag secure-image-service-backend:$(date +%s) ./backend\n",
  ".gitignore": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n\n# Go workspace file\ngo.work\ngo.work.sum\n\n# Environment variables\n.env\n\n# Docker\ndocker-compose.override.yml\ndocker-compose.local.yml\n\n# Build\n/build\n/dist\n\n# IDE\n.idea/\n.vscode/\n*.swp\n*~\n",
  "Makefile": ".PHONY: up down logs db-reset\n\nup:\n\tdocker-compose up -d --build\n\ndown:\n\tdocker-compose down\n\nlogs:\n\tdocker-compose logs -f backend\n\ndb-reset:\n\tdocker-compose down -v\n\tdocker-compose up -d db\n\t@echo \"Waiting for database to be ready...\"\n\t@sleep 5\n\tdocker-compose up -d backend frontend minio\n",
  "README.md": "# Project: Secure Software Supply Chain MVP\n\nThis project is a Minimum Viable Product (MVP) for a simulated secure software supply chain platform. Inspired by tools like Chainguard, Cosign, Sigstore, and SLSA, it provides a demo-capable system that models how organizations can build, verify, distribute, and track container images in a secure, traceable, and auditable manner.\n\nThe system is built using containerized services orchestrated via `docker-compose`, and is suitable for demo environments, internal prototyping, or design validation.\n\n## Features\n\n- **Security-First Design**: Images carry associated metadata like signed SBOMs, provenance, and build attestations (simulated).\n- **Traceability**: Builds are linked to source events (e.g. upstream changes, CVE discovery, or scheduled rebuilds).\n- **Multi-Tenant Support**: Tenants are logically isolated and tracked across the system.\n- **SBOM Handling**: SBOMs are generated in both SPDX and CycloneDX formats and stored in an accessible object store (MinIO).\n- **CVE Monitoring**: Each image is scanned for known vulnerabilities, triggering SLA timers and alerting logic.\n- **Explorability**: A minimalistic web frontend supports exploration of images, metadata, and CVE details.\n- **Simulated Systems**: All integrations with external systems (e.g. Rekor, Sigstore, CVE databases) are stubbed or mocked.\n\n## Architecture\n\nThe system is composed of several containerized services:\n\n- **Backend (Go)**: A Go application built using Clean Architecture principles, exposing a REST API.\n- **Frontend (Vanilla JS)**: A lightweight, static frontend served by Nginx for exploring the data.\n- **PostgreSQL**: The primary metadata database for all structured data.\n- **MinIO**: An S3-compatible object store for artifacts like SBOMs, logs, and attestations.\n\nAll services are orchestrated using `docker-compose`.\n\nFor a detailed overview, see the [Architecture Documentation](./docs/architecture.md).\n\n## Getting Started\n\n### Prerequisites\n\n- Docker\n- Docker Compose\n\n### Setup\n\n1.  **Clone the repository:**\n    ```sh\n    git clone https://github.com/your-username/secure-image-service.git\n    cd secure-image-service\n    ```\n\n2.  **Configure environment variables:**\n    Copy the example environment file. The default values are suitable for local development.\n    ```sh\n    cp .env.example .env\n    ```\n\n3.  **Start the services:**\n    Use the provided `Makefile` to build and start all services.\n    ```sh\n    make up\n    ```\n    This command will start the backend, frontend, database, and MinIO in detached mode.\n\n### Accessing the Services\n\n- **Frontend UI**: [http://localhost](http://localhost)\n- **Backend API**: [http://localhost:8080](http://localhost:8080)\n- **MinIO Console**: [http://localhost:9001](http://localhost:9001) (Credentials: `minioadmin` / `minioadmin`)\n\n## Development\n\nThe `Makefile` provides several commands to simplify the development workflow:\n\n- `make up`: Build and start all services in detached mode.\n- `make down`: Stop and remove all containers, networks, and volumes.\n- `make logs`: Tail the logs for the `backend` service.\n- `make db-reset`: A destructive command that completely stops the stack, wipes the database and MinIO volumes, and restarts the services. This is useful for re-applying the seed data from scratch.\n\n## API\n\nThe backend exposes a RESTful API for interacting with the system. For detailed information on endpoints, requests, and responses, please see the [API Documentation](./docs/api.md).\n\nA mock API key (`mock-api-key`) or JWT (`mock-jwt-token`) is required for authenticated endpoints.\n\n**Example cURL:**\n```sh\ncurl -H \"X-API-Key: mock-api-key\" http://localhost:8080/v1/images\n```\n\n## Project Structure\n\nThe project is organized as a monorepo:\n\n```\n/\n├── .github/          # GitHub Actions CI workflows\n├── backend/          # Go backend service (Clean Architecture)\n├── frontend/         # Vanilla JS frontend (static assets)\n├── deployments/      # Docker Compose, seed scripts, etc.\n├── docs/             # Architecture and API documentation\n├── .env.example      # Sample environment variables\n├── Makefile          # Development helper commands\n└── README.md         # This file\n```\n",
  "backend/Dockerfile": "# Stage 1: Build the application\nFROM golang:1.21-alpine AS builder\n\nWORKDIR /app\n\n# Copy go.mod and go.sum files to download dependencies\nCOPY go.mod go.sum ./\nRUN go mod download\n\n# Copy the rest of the application source code\nCOPY . .\n\n# Build the application\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o secure-image-service ./cmd/server\n\n# Stage 2: Create the final, smaller image\nFROM alpine:latest\n\nWORKDIR /root/\n\n# Copy the binary from the builder stage\nCOPY --from=builder /app/secure-image-service .\n\n# Expose the port the app runs on\nEXPOSE 8080\n\n# Command to run the executable\nCMD [\"./secure-image-service\"]\n",
  "backend/cmd/server/main.go": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/joho/godotenv\"\n\thttp_adapter \"secure-image-service/backend/internal/adapter/handler/http\"\n\t\"secure-image-service/backend/internal/adapter/postgres\"\n\t\"secure-image-service/backend/internal/adapter/simulator\"\n\t\"secure-image-service/backend/internal/usecase\"\n\t\"secure-image-service/backend/pkg/config\"\n\t\"secure-image-service/backend/pkg/logger\"\n)\n\nfunc main() {\n\t// Load .env file for local development\n\t_ = godotenv.Load()\n\n\t// Initialize logger\n\tlog := logger.New()\n\n\t// Load configuration\n\tcfg, err := config.Load()\n\tif err != nil {\n\t\tlog.Fatal().Err(err).Msg(\"Failed to load configuration\")\n\t}\n\n\t// Set up context for graceful shutdown\n\tctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)\n\tdefer stop()\n\n\t// Establish database connection\n\tdbPool, err := postgres.NewConnection(ctx, cfg.DatabaseURL)\n\tif err != nil {\n\t\tlog.Fatal().Err(err).Msg(\"Failed to connect to database\")\n\t}\n\tdefer dbPool.Close()\n\tlog.Info().Msg(\"Database connection established\")\n\n\t// Initialize repositories\n\timageRepo := postgres.NewImageRepository(dbPool)\n\tcustomerRepo := postgres.NewCustomerRepository(dbPool)\n\tbuildEventRepo := postgres.NewBuildEventRepository(dbPool)\n\tsbomRepo := postgres.NewSBOMRecordRepository(dbPool)\n\tcveRepo := postgres.NewCVEFindingRepository(dbPool)\n\tauditRepo := postgres.NewAuditLogRepository(dbPool)\n\n\t// Initialize simulators\n\torchestrator := simulator.NewMockBuildOrchestrator()\n\n\t// Initialize use cases\n\tauditUsecase := usecase.NewAuditUsecase(auditRepo)\n\timageUsecase := usecase.NewImageUsecase(imageRepo, buildEventRepo, orchestrator, auditUsecase)\n\tcustomerUsecase := usecase.NewCustomerUsecase(customerRepo)\n\tbuildUsecase := usecase.NewBuildUsecase(buildEventRepo, imageRepo, sbomRepo, cveRepo)\n\n\t// Initialize HTTP server\n\tserver := http_adapter.NewServer(imageUsecase, customerUsecase, buildUsecase, log)\n\thttpServer := \u0026http.Server{\n\t\tAddr:    fmt.Sprintf(\":%s\", cfg.APIPort),\n\t\tHandler: server,\n\t}\n\n\t// Start server in a goroutine\n\tgo func() {\n\t\tlog.Info().Msgf(\"Server starting on port %s\", cfg.APIPort)\n\t\tif err := httpServer.ListenAndServe(); err != nil \u0026\u0026 !errors.Is(err, http.ErrServerClosed) {\n\t\t\tlog.Fatal().Err(err).Msg(\"Server failed to start\")\n\t\t}\n\t}()\n\n\t// Wait for shutdown signal\n\t\u003c-ctx.Done()\n\n\t// Graceful shutdown\n\tlog.Info().Msg(\"Shutting down server...\")\n\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tif err := httpServer.Shutdown(shutdownCtx); err != nil {\n\t\tlog.Fatal().Err(err).Msg(\"Server shutdown failed\")\n\t}\n\n\tif err := server.Shutdown(shutdownCtx); err != nil {\n\t\tlog.Error().Err(err).Msg(\"Error during server custom shutdown\")\n\t}\n\n\tlog.Info().Msg(\"Server gracefully stopped\")\n}\n",
  "backend/go.mod": "module secure-image-service\n\ngo 1.21\n\nrequire (\n\tgithub.com/go-chi/chi/v5 v5.0.12\n\tgithub.com/jackc/pgx/v5 v5.5.5\n\tgithub.com/joho/godotenv v1.5.1\n\tgithub.com/rs/zerolog v1.32.0\n)\n\nrequire (\n\tgithub.com/jackc/pgpassfile v1.0.0 // indirect\n\tgithub.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect\n\tgithub.com/jackc/puddle/v2 v2.2.1 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.19 // indirect\n\tgolang.org/x/crypto v0.17.0 // indirect\n\tgolang.org/x/sync v0.1.0 // indirect\n\tgolang.org/x/sys v0.15.0 // indirect\n\tgolang.org/x/text v0.14.0 // indirect\n)\n",
  "backend/internal/adapter/handler/http/build_handler.go": "package http\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"secure-image-service/internal/usecase\"\n\t\"strconv\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype BuildHandler struct {\n\tusecase *usecase.BuildUsecase\n}\n\nfunc NewBuildHandler(uc *usecase.BuildUsecase) *BuildHandler {\n\treturn \u0026BuildHandler{usecase: uc}\n}\n\nfunc (h *BuildHandler) CompleteBuild(w http.ResponseWriter, r *http.Request) {\n\tbuildIDStr := chi.URLParam(r, \"buildID\")\n\tbuildID, err := strconv.Atoi(buildIDStr)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusBadRequest, \"Invalid build ID\")\n\t\treturn\n\t}\n\n\tvar req usecase.BuildCompletionRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\trespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\timage, err := h.usecase.CompleteBuild(r.Context(), buildID, req)\n\tif err != nil {\n\t\t// Consider more specific error codes based on err type\n\t\trespondWithError(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusCreated, image)\n}\n",
  "backend/internal/adapter/handler/http/customer_handler.go": "package http\n\nimport (\n\t\"net/http\"\n\t\"secure-image-service/internal/usecase\"\n\n\t\"github.com/go-chi/chi/v5\"\n)\n\ntype CustomerHandler struct {\n\tusecase *usecase.CustomerUsecase\n}\n\nfunc NewCustomerHandler(uc *usecase.CustomerUsecase) *CustomerHandler {\n\treturn \u0026CustomerHandler{usecase: uc}\n}\n\nfunc (h *CustomerHandler) ListCustomers(w http.ResponseWriter, r *http.Request) {\n\tcustomers, err := h.usecase.ListCustomers(r.Context())\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, \"Failed to retrieve customers\")\n\t\treturn\n\t}\n\trespondWithJSON(w, http.StatusOK, customers)\n}\n\nfunc (h *CustomerHandler) GetCustomer(w http.ResponseWriter, r *http.Request) {\n\tnamespace := chi.URLParam(r, \"namespace\")\n\tcustomer, err := h.usecase.GetCustomer(r.Context(), namespace)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, \"Failed to retrieve customer\")\n\t\treturn\n\t}\n\tif customer == nil {\n\t\trespondWithError(w, http.StatusNotFound, \"Customer not found\")\n\t\treturn\n\t}\n\trespondWithJSON(w, http.StatusOK, customer)\n}\n",
  "backend/internal/adapter/handler/http/image_handler.go": "package http\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"secure-image-service/internal/usecase\"\n)\n\n// ImageHandler handles HTTP requests for images.\ntype ImageHandler struct {\n\tusecase *usecase.ImageUsecase\n}\n\n// NewImageHandler creates a new ImageHandler.\nfunc NewImageHandler(uc *usecase.ImageUsecase) *ImageHandler {\n\treturn \u0026ImageHandler{usecase: uc}\n}\n\ntype CreateBuildRequest struct {\n\tTenantNamespace string `json:\"tenant_namespace\"`\n}\n\n// CreateBuild handles POST requests to trigger a new image build.\nfunc (h *ImageHandler) CreateBuild(w http.ResponseWriter, r *http.Request) {\n\tvar req CreateBuildRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\trespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\tif req.TenantNamespace == \"\" {\n\t\trespondWithError(w, http.StatusBadRequest, \"tenant_namespace is required\")\n\t\treturn\n\t}\n\n\t// For now, all builds are triggered via API\n\ttriggerType := \"api\"\n\n\tbuildEvent, err := h.usecase.CreateBuild(r.Context(), req.TenantNamespace, triggerType)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusAccepted, buildEvent)\n}\n\n// ListImages handles GET requests to retrieve all images.\nfunc (h *ImageHandler) ListImages(w http.ResponseWriter, r *http.Request) {\n\timages, err := h.usecase.ListImages(r.Context())\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, \"Could not retrieve images\")\n\t\treturn\n\t}\n\trespondWithJSON(w, http.StatusOK, images)\n}\n\n// GetImage handles GET requests for a specific image.\nfunc (h *ImageHandler) GetImage(w http.ResponseWriter, r *http.Request) {\n\tidStr := chi.URLParam(r, \"id\")\n\tid, err := strconv.Atoi(idStr)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusBadRequest, \"Invalid image ID\")\n\t\treturn\n\t}\n\n\timage, err := h.usecase.GetImage(r.Context(), id)\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, \"Could not retrieve image\")\n\t\treturn\n\t}\n\tif image == nil {\n\t\trespondWithError(w, http.StatusNotFound, \"Image not found\")\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusOK, image)\n}\n\n// GetImageSBOMs returns mocked SBOM data for a given image ID.\nfunc (h *ImageHandler) GetImageSBOMs(w http.ResponseWriter, r *http.Request) {\n\t// This is mocked for the MVP. A real implementation would fetch from the db.\n\tmockSBOMs := []map[string]string{\n\t\t{\"format\": \"SPDX\", \"uri\": \"minio://sboms/image-1/sbom.spdx.json\"},\n\t\t{\"format\": \"CycloneDX\", \"uri\": \"minio://sboms/image-1/sbom.cyclonedx.json\"},\n\t}\n\trespondWithJSON(w, http.StatusOK, mockSBOMs)\n}\n\n// GetImageCVEs returns mocked CVE data for a given image ID.\nfunc (h *ImageHandler) GetImageCVEs(w http.ResponseWriter, r *http.Request) {\n\t// This is mocked for the MVP. A real implementation would fetch from the db.\n\tidStr := chi.URLParam(r, \"id\")\n\tvar mockCVEs []map[string]interface{}\n\tif idStr == \"1\" {\n\t\tmockCVEs = []map[string]interface{}{\n\t\t\t{\"cve_id\": \"CVE-2023-12345\", \"severity\": \"High\", \"fix_available\": true},\n\t\t\t{\"cve_id\": \"CVE-2023-67890\", \"severity\": \"Medium\", \"fix_available\": false},\n\t\t}\n\t} else {\n\t\tmockCVEs = []map[string]interface{}{\n\t\t\t{\"cve_id\": \"CVE-2023-54321\", \"severity\": \"Critical\", \"fix_available\": true},\n\t\t}\n\t}\n\trespondWithJSON(w, http.StatusOK, mockCVEs)\n}\n\n// GetImageVerification returns mocked verification data for a given image ID.\nfunc (h *ImageHandler) GetImageVerification(w http.ResponseWriter, r *http.Request) {\n\t// This is mocked for the MVP.\n\tmockVerification := map[string]interface{}{\n\t\t\"signature\": map[string]string{\n\t\t\t\"key_id\":    \"gcpkms://projects/secure-project/locations/global/keyRings/cosign/cryptoKeys/prod-key\",\n\t\t\t\"signature\": \"MEUCIQ...\",\n\t\t},\n\t\t\"rekor_entry\": \"https://rekor.sigstore.dev/api/v1/log/entries/...\",\n\t\t\"attestations\": []map[string]string{\n\t\t\t{\"type\": \"provenance\", \"uri\": \"minio://attestations/image-1/provenance.json\"},\n\t\t\t{\"type\": \"vuln-scan\", \"uri\": \"minio://attestations/image-1/scan-report.json\"},\n\t\t},\n\t}\n\trespondWithJSON(w, http.StatusOK, mockVerification)\n}\n\n// respondWithError is a helper to write a JSON error response.\nfunc respondWithError(w http.ResponseWriter, code int, message string) {\n\trespondWithJSON(w, code, map[string]string{\"error\": message})\n}\n\n// respondWithJSON is a helper to write a JSON response.\nfunc respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {\n\tresponse, _ := json.Marshal(payload)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(code)\n\tw.Write(response)\n}",
  "backend/internal/adapter/handler/http/middleware/auth.go": "package middleware\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n)\n\n// Mock credentials\nconst (\n\tmockAPIKey   = \"mock-api-key\"\n\tmockJWTToken = \"mock-jwt-token\"\n)\n\n// Authenticator is a simple middleware to check for a mock API key or JWT token.\nfunc Authenticator(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Check for API Key\n\t\tapiKey := r.Header.Get(\"X-API-Key\")\n\t\tif apiKey == mockAPIKey {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\t// Check for Bearer Token\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\tif strings.HasPrefix(authHeader, \"Bearer \") {\n\t\t\ttoken := strings.TrimPrefix(authHeader, \"Bearer \")\n\t\t\tif token == mockJWTToken {\n\t\t\t\tnext.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t})\n}\n",
  "backend/internal/adapter/handler/http/server.go": "package http_adapter\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"secure-image-service/backend/internal/adapter/handler/http/middleware\"\n\t\"secure-image-service/backend/internal/usecase\"\n\n\t\"github.com/go-chi/chi/v5\"\n\tchi_middleware \"github.com/go-chi/chi/v5/middleware\"\n\t\"github.com/rs/zerolog\"\n)\n\n// Server represents the HTTP server.\ntype Server struct {\n\tRouter          *chi.Mux\n\tImageHandler    *ImageHandler\n\tCustomerHandler *CustomerHandler\n\tBuildHandler    *BuildHandler\n\tWebhookHandler  *WebhookHandler\n\tLogger          zerolog.Logger\n}\n\n// NewServer creates and configures a new Server instance.\nfunc NewServer(\n\timageUsecase *usecase.ImageUsecase,\n\tcustomerUsecase *usecase.CustomerUsecase,\n\tbuildUsecase *usecase.BuildUsecase,\n\tlogger zerolog.Logger,\n) *Server {\n\ts := \u0026Server{\n\t\tRouter:          chi.NewRouter(),\n\t\tImageHandler:    NewImageHandler(imageUsecase),\n\t\tCustomerHandler: NewCustomerHandler(customerUsecase),\n\t\tBuildHandler:    NewBuildHandler(buildUsecase),\n\t\tWebhookHandler:  NewWebhookHandler(imageUsecase),\n\t\tLogger:          logger,\n\t}\n\ts.setupRoutes()\n\treturn s\n}\n\nfunc (s *Server) setupRoutes() {\n\t// Middleware\n\ts.Router.Use(chi_middleware.RequestID)\n\ts.Router.Use(chi_middleware.RealIP)\n\ts.Router.Use(chi_middleware.Logger)\n\ts.Router.Use(chi_middleware.Recoverer)\n\ts.Router.Use(chi_middleware.Timeout(60 * time.Second))\n\n\t// Public routes\n\ts.Router.Get(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\t// API v1 routes with authentication\n\ts.Router.Route(\"/v1\", func(r chi.Router) {\n\t\tr.Use(middleware.Authenticator)\n\n\t\t// Image routes\n\t\tr.Get(\"/images\", s.ImageHandler.ListImages)\n\t\tr.Post(\"/images\", s.ImageHandler.CreateBuild)\n\t\tr.Get(\"/images/{id}\", s.ImageHandler.GetImage)\n\t\tr.Get(\"/images/{id}/sbom\", s.ImageHandler.GetImageSBOMs)\n\t\tr.Get(\"/images/{id}/cves\", s.ImageHandler.GetImageCVEs)\n\t\tr.Get(\"/images/{id}/verify\", s.ImageHandler.GetImageVerification)\n\n\t\t// Customer routes\n\t\tr.Get(\"/customers\", s.CustomerHandler.ListCustomers)\n\t\tr.Get(\"/customers/{namespace}\", s.CustomerHandler.GetCustomer)\n\n\t\t// Build routes\n\t\tr.Post(\"/builds/{buildID}/complete\", s.BuildHandler.CompleteBuild)\n\n\t\t// Webhook routes\n\t\tr.Post(\"/webhooks/upstream\", s.WebhookHandler.TriggerUpstreamBuild)\n\t})\n}\n\n// ServeHTTP implements the http.Handler interface.\nfunc (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\ts.Router.ServeHTTP(w, r)\n}\n\n// Shutdown is a placeholder for graceful server shutdown.\nfunc (s *Server) Shutdown(ctx context.Context) error {\n\ts.Logger.Info().Msg(\"Server shutdown complete.\")\n\treturn nil\n}\n",
  "backend/internal/adapter/handler/http/webhook_handler.go": "package http_adapter\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"secure-image-service/backend/internal/usecase\"\n)\n\ntype WebhookHandler struct {\n\tusecase *usecase.ImageUsecase\n}\n\nfunc NewWebhookHandler(uc *usecase.ImageUsecase) *WebhookHandler {\n\treturn \u0026WebhookHandler{usecase: uc}\n}\n\ntype UpstreamWebhookRequest struct {\n\tTenantNamespace string `json:\"tenant_namespace\"`\n}\n\nfunc (h *WebhookHandler) TriggerUpstreamBuild(w http.ResponseWriter, r *http.Request) {\n\tvar req UpstreamWebhookRequest\n\tif err := json.NewDecoder(r.Body).Decode(\u0026req); err != nil {\n\t\trespondWithError(w, http.StatusBadRequest, \"Invalid request payload\")\n\t\treturn\n\t}\n\n\tif req.TenantNamespace == \"\" {\n\t\trespondWithError(w, http.StatusBadRequest, \"tenant_namespace is required\")\n\t\treturn\n\t}\n\n\tbuildEvent, err := h.usecase.CreateBuild(r.Context(), req.TenantNamespace, \"webhook\")\n\tif err != nil {\n\t\trespondWithError(w, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\trespondWithJSON(w, http.StatusAccepted, buildEvent)\n}\n",
  "backend/internal/adapter/postgres/audit_log_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"secure-image-service/backend/internal/domain\"\n\t\"secure-image-service/backend/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype pgAuditLogRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewAuditLogRepository(db *pgxpool.Pool) repository.AuditLogRepository {\n\treturn \u0026pgAuditLogRepository{db: db}\n}\n\nfunc (r *pgAuditLogRepository) Create(ctx context.Context, log *domain.AuditLog) error {\n\tdetailsJSON, err := json.Marshal(log.Details)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tquery := `\n        INSERT INTO audit_logs (tenant_namespace, action, actor, details)\n        VALUES ($1, $2, $3, $4)\n    `\n\t_, err = r.db.Exec(ctx, query, log.TenantNamespace, log.Action, log.Actor, detailsJSON)\n\treturn err\n}\n",
  "backend/internal/adapter/postgres/build_event_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\ntype pgBuildEventRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewBuildEventRepository(db *pgxpool.Pool) repository.BuildEventRepository {\n\treturn \u0026pgBuildEventRepository{db: db}\n}\n\nfunc (r *pgBuildEventRepository) Create(ctx context.Context, event *domain.BuildEvent) (int, error) {\n\tquery := `INSERT INTO build_events (tenant_namespace, trigger_type, status)\n              VALUES ($1, $2, $3) RETURNING id, created_at, updated_at`\n\terr := r.db.QueryRow(ctx, query, event.TenantNamespace, event.TriggerType, event.Status).Scan(\u0026event.ID, \u0026event.CreatedAt, \u0026event.UpdatedAt)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn event.ID, nil\n}\n\nfunc (r *pgBuildEventRepository) FindByID(ctx context.Context, id int) (*domain.BuildEvent, error) {\n\tquery := `SELECT id, tenant_namespace, image_id, trigger_type, status, created_at, updated_at\n              FROM build_events WHERE id = $1`\n\tevent := \u0026domain.BuildEvent{}\n\terr := r.db.QueryRow(ctx, query, id).Scan(\n\t\t\u0026event.ID, \u0026event.TenantNamespace, \u0026event.ImageID, \u0026event.TriggerType,\n\t\t\u0026event.Status, \u0026event.CreatedAt, \u0026event.UpdatedAt,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn event, nil\n}\n\nfunc (r *pgBuildEventRepository) Update(ctx context.Context, event *domain.BuildEvent) error {\n\tquery := `UPDATE build_events SET image_id = $1, status = $2, updated_at = NOW()\n              WHERE id = $3`\n\t_, err := r.db.Exec(ctx, query, event.ImageID, event.Status, event.ID)\n\treturn err\n}\n",
  "backend/internal/adapter/postgres/customer_image_usage_repository.go": "package postgres\n\n// This file is a placeholder for the MVP.\n// The repository is defined but not yet implemented as no use cases require it in this step.\n",
  "backend/internal/adapter/postgres/customer_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype pgCustomerRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewCustomerRepository(db *pgxpool.Pool) repository.CustomerRepository {\n\treturn \u0026pgCustomerRepository{db: db}\n}\n\nfunc (r *pgCustomerRepository) FindAll(ctx context.Context) ([]*domain.Customer, error) {\n\trows, err := r.db.Query(ctx, \"SELECT namespace, name, contact_info, sla_tier, created_at, updated_at FROM customers ORDER BY name\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tcustomers, err := pgx.CollectRows(rows, pgx.RowToAddrOfStructByPos[domain.Customer])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn customers, nil\n}\n\nfunc (r *pgCustomerRepository) FindByNamespace(ctx context.Context, namespace string) (*domain.Customer, error) {\n\trow := r.db.QueryRow(ctx, \"SELECT namespace, name, contact_info, sla_tier, created_at, updated_at FROM customers WHERE namespace = $1\", namespace)\n\n\tcustomer, err := pgx.RowToAddrOfStructByPos[domain.Customer](row)\n\tif err != nil {\n\t\tif errors.Is(err, pgx.ErrNoRows) {\n\t\t\treturn nil, nil // Not found is not an error\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn customer, nil\n}\n",
  "backend/internal/adapter/postgres/cve_finding_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\ntype pgCVEFindingRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewCVEFindingRepository(db *pgxpool.Pool) repository.CVEFindingRepository {\n\treturn \u0026pgCVEFindingRepository{db: db}\n}\n\nfunc (r *pgCVEFindingRepository) CreateBatch(ctx context.Context, cves []*domain.CVEFinding) error {\n\tif len(cves) == 0 {\n\t\treturn nil\n\t}\n\n\tbatch := \u0026pgx.Batch{}\n\tquery := `INSERT INTO cve_findings (image_id, cve_id, severity, description, fix_available)\n              VALUES ($1, $2, $3, $4, $5)`\n\n\tfor _, cve := range cves {\n\t\tbatch.Queue(query, cve.ImageID, cve.CVEID, cve.Severity, cve.Description, cve.FixAvailable)\n\t}\n\n\tbr := r.db.SendBatch(ctx, batch)\n\tdefer br.Close()\n\n\tfor i := 0; i \u003c len(cves); i++ {\n\t\tif _, err := br.Exec(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n",
  "backend/internal/adapter/postgres/db.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\nfunc NewConnection(ctx context.Context, connString string) (*pgxpool.Pool, error) {\n\tpool, err := pgxpool.New(ctx, connString)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create connection pool: %w\", err)\n\t}\n\n\tif err := pool.Ping(ctx); err != nil {\n\t\tpool.Close()\n\t\treturn nil, fmt.Errorf(\"unable to ping database: %w\", err)\n\t}\n\n\treturn pool, nil\n}\n",
  "backend/internal/adapter/postgres/image_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\t\"github.com/lib/pq\"\n)\n\ntype pgImageRepository struct {\n\tdb *pgxpool.Pool\n}\n\n// NewImageRepository creates a new PostgreSQL-backed ImageRepository.\nfunc NewImageRepository(db *pgxpool.Pool) repository.ImageRepository {\n\treturn \u0026pgImageRepository{db: db}\n}\n\n// FindAll retrieves all images from the database.\nfunc (r *pgImageRepository) FindAll(ctx context.Context) ([]*domain.Image, error) {\n\tquery := `SELECT id, tenant_namespace, digest, tags, slsa_level, created_at, updated_at FROM images ORDER BY created_at DESC`\n\trows, err := r.db.Query(ctx, query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar images []*domain.Image\n\tfor rows.Next() {\n\t\tvar image domain.Image\n\t\tvar tags pq.StringArray\n\t\tif err := rows.Scan(\u0026image.ID, \u0026image.TenantNamespace, \u0026image.Digest, \u0026tags, \u0026image.SLSALevel, \u0026image.CreatedAt, \u0026image.UpdatedAt); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\timage.Tags = tags\n\t\timages = append(images, \u0026image)\n\t}\n\n\treturn images, nil\n}\n\n// FindByID retrieves a single image by its ID.\nfunc (r *pgImageRepository) FindByID(ctx context.Context, id int) (*domain.Image, error) {\n\tquery := `SELECT id, tenant_namespace, digest, tags, slsa_level, created_at, updated_at FROM images WHERE id = $1`\n\tvar image domain.Image\n\tvar tags pq.StringArray\n\terr := r.db.QueryRow(ctx, query, id).Scan(\u0026image.ID, \u0026image.TenantNamespace, \u0026image.Digest, \u0026tags, \u0026image.SLSALevel, \u0026image.CreatedAt, \u0026image.UpdatedAt)\n\tif err != nil {\n\t\tif err == pgx.ErrNoRows {\n\t\t\treturn nil, nil // Not found is not an error\n\t\t}\n\t\treturn nil, err\n\t}\n\timage.Tags = tags\n\treturn \u0026image, nil\n}\n\nfunc (r *pgImageRepository) Create(ctx context.Context, image *domain.Image) (int, error) {\n\tquery := `INSERT INTO images (tenant_namespace, digest, tags, slsa_level)\n              VALUES ($1, $2, $3, $4) RETURNING id, created_at, updated_at`\n\terr := r.db.QueryRow(ctx, query, image.TenantNamespace, image.Digest, pq.Array(image.Tags), image.SLSALevel).Scan(\u0026image.ID, \u0026image.CreatedAt, \u0026image.UpdatedAt)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn image.ID, nil\n}",
  "backend/internal/adapter/postgres/notification_repository.go": "package postgres\n\n// This file is a placeholder for the MVP.\n// The repository is defined but not yet implemented as no use cases require it in this step.\n",
  "backend/internal/adapter/postgres/sbom_record_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\ntype pgSBOMRecordRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewSBOMRecordRepository(db *pgxpool.Pool) repository.SBOMRecordRepository {\n\treturn \u0026pgSBOMRecordRepository{db: db}\n}\n\nfunc (r *pgSBOMRecordRepository) Create(ctx context.Context, sbom *domain.SBOMRecord) error {\n\tquery := `INSERT INTO sbom_records (image_id, format, uri) VALUES ($1, $2, $3)`\n\t_, err := r.db.Exec(ctx, query, sbom.ImageID, sbom.Format, sbom.URI)\n\treturn err\n}\n",
  "backend/internal/adapter/postgres/sla_violation_repository.go": "package postgres\n\nimport (\n\t\"context\"\n\t\"secure-image-service/backend/internal/domain\"\n\t\"secure-image-service/backend/internal/repository\"\n\n\t\"github.com/jackc/pgx/v5/pgxpool\"\n)\n\ntype pgSLAViolationRepository struct {\n\tdb *pgxpool.Pool\n}\n\nfunc NewSLAViolationRepository(db *pgxpool.Pool) repository.SLAViolationRepository {\n\treturn \u0026pgSLAViolationRepository{db: db}\n}\n\nfunc (r *pgSLAViolationRepository) Create(ctx context.Context, violation *domain.SLAViolation) error {\n\tquery := `\n        INSERT INTO sla_violations (tenant_namespace, cve_finding_id, status)\n        VALUES ($1, $2, $3)\n    `\n\t_, err := r.db.Exec(ctx, query, violation.TenantNamespace, violation.CVEFindingID, violation.Status)\n\treturn err\n}\n",
  "backend/internal/adapter/simulator/orchestrator.go": "package simulator\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"secure-image-service/internal/domain\"\n)\n\ntype BuildOrchestrator interface {\n\tTriggerBuild(ctx context.Context, event *domain.BuildEvent) error\n}\n\ntype MockBuildOrchestrator struct{}\n\nfunc NewMockBuildOrchestrator() BuildOrchestrator {\n\treturn \u0026MockBuildOrchestrator{}\n}\n\nfunc (m *MockBuildOrchestrator) TriggerBuild(ctx context.Context, event *domain.BuildEvent) error {\n\tlog.Printf(\"SIMULATOR: Triggering build for event ID %d (tenant: %s)\", event.ID, event.TenantNamespace)\n\t// In a real system, this would call a CI/CD system (e.g., Jenkins, GitLab CI).\n\t// For this MVP, we just log the action. The build completion is simulated\n\t// by a separate API call to POST /v1/builds/{build_id}/complete.\n\treturn nil\n}\n",
  "backend/internal/domain/audit_log.go": "package domain\n\nimport \"time\"\n\ntype AuditLog struct {\n\tID              int                    `json:\"id\"`\n\tTenantNamespace string                 `json:\"tenant_namespace\"`\n\tAction          string                 `json:\"action\"`\n\tActor           string                 `json:\"actor\"` // e.g., user ID, API key ID, system process\n\tDetails         map[string]interface{} `json:\"details\"`\n\tTimestamp       time.Time              `json:\"timestamp\"`\n}\n",
  "backend/internal/domain/build_event.go": "package domain\n\nimport \"time\"\n\ntype BuildEvent struct {\n\tID              int       `json:\"id\"`\n\tTenantNamespace string    `json:\"tenant_namespace\"`\n\tImageID         *int      `json:\"image_id,omitempty\"` // Pointer to allow null\n\tTriggerType     string    `json:\"trigger_type\"`\n\tStatus          string    `json:\"status\"`\n\tCreatedAt       time.Time `json:\"created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\"`\n}\n",
  "backend/internal/domain/customer.go": "package domain\n\nimport \"time\"\n\ntype Customer struct {\n\tNamespace    string    `json:\"namespace\"`\n\tName         string    `json:\"name\"`\n\tContactInfo  string    `json:\"contact_info\"`\n\tSLATier      string    `json:\"sla_tier\"`\n\tCreatedAt    time.Time `json:\"created_at\"`\n\tUpdatedAt    time.Time `json:\"updated_at\"`\n}\n",
  "backend/internal/domain/customer_image_usage.go": "package domain\n\nimport \"time\"\n\ntype CustomerImageUsage struct {\n\tID              int       `json:\"id\"`\n\tTenantNamespace string    `json:\"tenant_namespace\"`\n\tImageID         int       `json:\"image_id\"`\n\tVersionPinned   bool      `json:\"version_pinned\"`\n\tRuntimeInfo     string    `json:\"runtime_info\"` // e.g., cluster name, environment\n\tCreatedAt       time.Time `json:\"created_at\"`\n}\n",
  "backend/internal/domain/cve_finding.go": "package domain\n\nimport \"time\"\n\ntype CVEFinding struct {\n\tID           int       `json:\"id\"`\n\tImageID      int       `json:\"image_id\"`\n\tCVEID        string    `json:\"cve_id\"`\n\tSeverity     string    `json:\"severity\"`\n\tDescription  string    `json:\"description\"`\n\tFixAvailable bool      `json:\"fix_available\"`\n\tCreatedAt    time.Time `json:\"created_at\"`\n}\n",
  "backend/internal/domain/image.go": "package domain\n\nimport (\n\t\"time\"\n)\n\ntype Image struct {\n\tID              int       `json:\"id\"`\n\tTenantNamespace string    `json:\"tenant_namespace\"`\n\tDigest          string    `json:\"digest\"`\n\tTags            []string  `json:\"tags\"`\n\tSLSALevel       int       `json:\"slsa_level\"`\n\tCreatedAt       time.Time `json:\"created_at\"`\n\tUpdatedAt       time.Time `json:\"updated_at\"`\n}\n",
  "backend/internal/domain/notification.go": "package domain\n\nimport \"time\"\n\ntype Notification struct {\n\tID              int       `json:\"id\"`\n\tTenantNamespace string    `json:\"tenant_namespace\"`\n\tType            string    `json:\"type\"` // e.g., \"SLA_VIOLATION\", \"BUILD_COMPLETE\"\n\tPayload         string    `json:\"payload\"`\n\tSentAt          time.Time `json:\"sent_at\"`\n\tStatus          string    `json:\"status\"` // e.g., \"sent\", \"failed\"\n}\n",
  "backend/internal/domain/sbom_record.go": "package domain\n\nimport \"time\"\n\ntype SBOMRecord struct {\n\tID        int       `json:\"id\"`\n\tImageID   int       `json:\"image_id\"`\n\tFormat    string    `json:\"format\"`\n\tURI       string    `json:\"uri\"`\n\tCreatedAt time.Time `json:\"created_at\"`\n}\n",
  "backend/internal/domain/sla_violation.go": "package domain\n\nimport \"time\"\n\ntype SLAViolation struct {\n\tID              int       `json:\"id\"`\n\tTenantNamespace string    `json:\"tenant_namespace\"`\n\tCVEFindingID    int       `json:\"cve_finding_id\"`\n\tStatus          string    `json:\"status\"` // e.g., \"active\", \"resolved\"\n\tCreatedAt       time.Time `json:\"created_at\"`\n\tResolvedAt      time.Time `json:\"resolved_at\"`\n}\n",
  "backend/internal/repository/audit_log.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/backend/internal/domain\"\n)\n\ntype AuditLogRepository interface {\n\tCreate(ctx context.Context, log *domain.AuditLog) error\n}\n",
  "backend/internal/repository/build_event.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n)\n\ntype BuildEventRepository interface {\n\tCreate(ctx context.Context, event *domain.BuildEvent) (int, error)\n\tFindByID(ctx context.Context, id int) (*domain.BuildEvent, error)\n\tUpdate(ctx context.Context, event *domain.BuildEvent) error\n}\n",
  "backend/internal/repository/customer.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n)\n\ntype CustomerRepository interface {\n\tFindAll(ctx context.Context) ([]*domain.Customer, error)\n\tFindByNamespace(ctx context.Context, namespace string) (*domain.Customer, error)\n}\n",
  "backend/internal/repository/customer_image_usage.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/backend/internal/domain\"\n)\n\ntype CustomerImageUsageRepository interface {\n\tCreate(ctx context.Context, usage *domain.CustomerImageUsage) error\n\tFindByTenant(ctx context.Context, tenantNamespace string) ([]*domain.CustomerImageUsage, error)\n}\n",
  "backend/internal/repository/cve_finding.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n)\n\ntype CVEFindingRepository interface {\n\tCreateBatch(ctx context.Context, cves []*domain.CVEFinding) error\n}\n",
  "backend/internal/repository/image.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n)\n\n// ImageRepository defines the interface for accessing image data.\ntype ImageRepository interface {\n\tFindAll(ctx context.Context) ([]*domain.Image, error)\n\tFindByID(ctx context.Context, id int) (*domain.Image, error)\n\tCreate(ctx context.Context, image *domain.Image) (int, error)\n}",
  "backend/internal/repository/notification.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/backend/internal/domain\"\n)\n\ntype NotificationRepository interface {\n\tCreate(ctx context.Context, notification *domain.Notification) error\n}\n",
  "backend/internal/repository/sbom_record.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n)\n\ntype SBOMRecordRepository interface {\n\tCreate(ctx context.Context, sbom *domain.SBOMRecord) error\n}\n",
  "backend/internal/repository/sla_violation.go": "package repository\n\nimport (\n\t\"context\"\n\t\"secure-image-service/backend/internal/domain\"\n)\n\ntype SLAViolationRepository interface {\n\tCreate(ctx context.Context, violation *domain.SLAViolation) error\n}\n",
  "backend/internal/usecase/audit_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"secure-image-service/backend/internal/domain\"\n\t\"secure-image-service/backend/internal/repository\"\n)\n\ntype AuditUsecase struct {\n\trepo repository.AuditLogRepository\n}\n\nfunc NewAuditUsecase(repo repository.AuditLogRepository) *AuditUsecase {\n\treturn \u0026AuditUsecase{repo: repo}\n}\n\nfunc (uc *AuditUsecase) Log(ctx context.Context, namespace, action, actor string, details map[string]interface{}) error {\n\tlogEntry := \u0026domain.AuditLog{\n\t\tTenantNamespace: namespace,\n\t\tAction:          action,\n\t\tActor:           actor,\n\t\tDetails:         details,\n\t}\n\treturn uc.repo.Create(ctx, logEntry)\n}\n",
  "backend/internal/usecase/build_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\ntype BuildCompletionRequest struct {\n\tImageDigest string            `json:\"image_digest\"`\n\tTags        []string          `json:\"tags\"`\n\tSLSALevel   int               `json:\"slsa_level\"`\n\tSBOMs       []SBOMInput       `json:\"sboms\"`\n\tCVEs        []CVEFindingInput `json:\"cves\"`\n}\n\ntype SBOMInput struct {\n\tFormat string `json:\"format\"`\n\tURI    string `json:\"uri\"`\n}\n\ntype CVEFindingInput struct {\n\tCVEID        string `json:\"cve_id\"`\n\tSeverity     string `json:\"severity\"`\n\tDescription  string `json:\"description\"`\n\tFixAvailable bool   `json:\"fix_available\"`\n}\n\ntype BuildUsecase struct {\n\tbuildRepo repository.BuildEventRepository\n\timageRepo repository.ImageRepository\n\tsbomRepo  repository.SBOMRecordRepository\n\tcveRepo   repository.CVEFindingRepository\n}\n\nfunc NewBuildUsecase(\n\tbuildRepo repository.BuildEventRepository,\n\timageRepo repository.ImageRepository,\n\tsbomRepo repository.SBOMRecordRepository,\n\tcveRepo repository.CVEFindingRepository,\n) *BuildUsecase {\n\treturn \u0026BuildUsecase{\n\t\tbuildRepo: buildRepo,\n\t\timageRepo: imageRepo,\n\t\tsbomRepo:  sbomRepo,\n\t\tcveRepo:   cveRepo,\n\t}\n}\n\nfunc (uc *BuildUsecase) CompleteBuild(ctx context.Context, buildID int, req BuildCompletionRequest) (*domain.Image, error) {\n\t// 1. Find the build event and validate its state\n\tbuildEvent, err := uc.buildRepo.FindByID(ctx, buildID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"build event not found: %w\", err)\n\t}\n\tif buildEvent.Status != \"pending\" {\n\t\treturn nil, fmt.Errorf(\"build event %d is not in 'pending' state, current state: %s\", buildID, buildEvent.Status)\n\t}\n\n\t// 2. Create the new image record\n\tnewImage := \u0026domain.Image{\n\t\tTenantNamespace: buildEvent.TenantNamespace,\n\t\tDigest:          req.ImageDigest,\n\t\tTags:            req.Tags,\n\t\tSLSALevel:       req.SLSALevel,\n\t}\n\timageID, err := uc.imageRepo.Create(ctx, newImage)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create image record: %w\", err)\n\t}\n\tnewImage.ID = imageID\n\n\t// 3. Create SBOM records\n\tfor _, sbomInput := range req.SBOMs {\n\t\tsbomRecord := \u0026domain.SBOMRecord{\n\t\t\tImageID: imageID,\n\t\t\tFormat:  sbomInput.Format,\n\t\t\tURI:     sbomInput.URI,\n\t\t}\n\t\tif err := uc.sbomRepo.Create(ctx, sbomRecord); err != nil {\n\t\t\t// In a real system, we'd want transactional behavior here\n\t\t\treturn nil, fmt.Errorf(\"failed to create sbom record: %w\", err)\n\t\t}\n\t}\n\n\t// 4. Create CVE finding records\n\tvar cveFindings []*domain.CVEFinding\n\tfor _, cveInput := range req.CVEs {\n\t\tcveFindings = append(cveFindings, \u0026domain.CVEFinding{\n\t\t\tImageID:      imageID,\n\t\t\tCVEID:        cveInput.CVEID,\n\t\t\tSeverity:     cveInput.Severity,\n\t\t\tDescription:  cveInput.Description,\n\t\t\tFixAvailable: cveInput.FixAvailable,\n\t\t})\n\t}\n\tif err := uc.cveRepo.CreateBatch(ctx, cveFindings); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create cve findings: %w\", err)\n\t}\n\n\t// 5. Update the build event with the new image_id and set status to 'completed'\n\tbuildEvent.ImageID = \u0026imageID\n\tbuildEvent.Status = \"completed\"\n\tif err := uc.buildRepo.Update(ctx, buildEvent); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to update build event: %w\", err)\n\t}\n\n\treturn newImage, nil\n}\n",
  "backend/internal/usecase/customer_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"secure-image-service/internal/domain\"\n\t\"secure-image-service/internal/repository\"\n)\n\ntype CustomerUsecase struct {\n\trepo repository.CustomerRepository\n}\n\nfunc NewCustomerUsecase(repo repository.CustomerRepository) *CustomerUsecase {\n\treturn \u0026CustomerUsecase{repo: repo}\n}\n\nfunc (uc *CustomerUsecase) ListCustomers(ctx context.Context) ([]*domain.Customer, error) {\n\treturn uc.repo.FindAll(ctx)\n}\n\nfunc (uc *CustomerUsecase) GetCustomer(ctx context.Context, namespace string) (*domain.Customer, error) {\n\treturn uc.repo.FindByNamespace(ctx, namespace)\n}\n",
  "backend/internal/usecase/image_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"secure-image-service/backend/internal/adapter/simulator\"\n\t\"secure-image-service/backend/internal/domain\"\n\t\"secure-image-service/backend/internal/repository\"\n)\n\n// ImageUsecase handles business logic for images.\ntype ImageUsecase struct {\n\trepo         repository.ImageRepository\n\tbuildRepo    repository.BuildEventRepository\n\torchestrator simulator.BuildOrchestrator\n\tauditUC      *AuditUsecase\n}\n\n// NewImageUsecase creates a new ImageUsecase.\nfunc NewImageUsecase(\n\trepo repository.ImageRepository,\n\tbuildRepo repository.BuildEventRepository,\n\torchestrator simulator.BuildOrchestrator,\n\tauditUC *AuditUsecase,\n) *ImageUsecase {\n\treturn \u0026ImageUsecase{\n\t\trepo:         repo,\n\t\tbuildRepo:    buildRepo,\n\t\torchestrator: orchestrator,\n\t\tauditUC:      auditUC,\n\t}\n}\n\n// ListImages retrieves all images.\nfunc (uc *ImageUsecase) ListImages(ctx context.Context) ([]*domain.Image, error) {\n\treturn uc.repo.FindAll(ctx)\n}\n\n// GetImage retrieves a single image by its ID.\nfunc (uc *ImageUsecase) GetImage(ctx context.Context, id int) (*domain.Image, error) {\n\treturn uc.repo.FindByID(ctx, id)\n}\n\n// CreateBuild creates a build event and triggers a simulated build.\nfunc (uc *ImageUsecase) CreateBuild(ctx context.Context, tenantNamespace, triggerType string) (*domain.BuildEvent, error) {\n\tbuildEvent := \u0026domain.BuildEvent{\n\t\tTenantNamespace: tenantNamespace,\n\t\tTriggerType:     triggerType,\n\t\tStatus:          \"pending\",\n\t}\n\n\tid, err := uc.buildRepo.Create(ctx, buildEvent)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbuildEvent.ID = id\n\n\t// Trigger the build process asynchronously\n\tgo uc.orchestrator.TriggerBuild(context.Background(), buildEvent)\n\n\t// Log the audit event\n\tauditDetails := map[string]interface{}{\n\t\t\"build_event_id\": id,\n\t\t\"trigger_type\":   triggerType,\n\t}\n\t// In a real system, actor would come from the request context (e.g., user ID, API key ID)\n\t_ = uc.auditUC.Log(ctx, tenantNamespace, \"build_triggered\", \"system\", auditDetails)\n\n\treturn buildEvent, nil\n}\n",
  "backend/internal/usecase/sla_usecase.go": "package usecase\n\nimport (\n\t\"context\"\n\t\"secure-image-service/backend/internal/repository\"\n\t\"time\"\n)\n\n// This is a simplified placeholder for demonstrating the concept.\n// A real implementation would be much more complex.\n\ntype SLAUsecase struct {\n\tslaRepo      repository.SLAViolationRepository\n\tcustomerRepo repository.CustomerRepository\n\t// In a real system, this would likely be a more complex CVE repository\n\t// that can query findings by age, severity, etc.\n}\n\nfunc NewSLAUsecase(\n\tslaRepo repository.SLAViolationRepository,\n\tcustomerRepo repository.CustomerRepository,\n) *SLAUsecase {\n\treturn \u0026SLAUsecase{\n\t\tslaRepo:      slaRepo,\n\t\tcustomerRepo: customerRepo,\n\t}\n}\n\n// CheckAllViolations simulates a background job that scans for SLA violations.\nfunc (uc *SLAUsecase) CheckAllViolations(ctx context.Context) error {\n\t// 1. Get all customers to check their SLA tiers.\n\tcustomers, err := uc.customerRepo.FindAll(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, customer := range customers {\n\t\t// 2. Define SLA deadlines based on tier.\n\t\tslaDeadline := 0\n\t\tswitch customer.SLATier {\n\t\tcase \"premium\":\n\t\t\tslaDeadline = 7 // 7 days for critical vulnerabilities\n\t\tcase \"standard\":\n\t\t\tslaDeadline = 30 // 30 days\n\t\tdefault:\n\t\t\tcontinue // No SLA for this tier\n\t\t}\n\n\t\t// 3. Find all critical CVEs for this customer that are older than the deadline.\n\t\t// THIS IS A MOCK. A real implementation would query the database.\n\t\t// e.g., cveRepo.FindUnresolvedCriticalCVEsOlderThan(ctx, customer.Namespace, time.Now().AddDate(0, 0, -slaDeadline))\n\t\t// For the MVP, we just log that we would perform this check.\n\t\t_ = slaDeadline\n\t\t// log.Printf(\"Checking for SLA violations for tenant %s with deadline %d days\", customer.Namespace, slaDeadline)\n\n\t\t// 4. If violations are found, create records in the sla_violations table.\n\t\t// e.g., for _, cve := range violations {\n\t\t//   uc.slaRepo.Create(ctx, \u0026domain.SLAViolation{...})\n\t\t// }\n\t}\n\n\treturn nil\n}\n",
  "backend/pkg/config/config.go": "package config\n\nimport (\n\t\"os\"\n\t\"strconv\"\n)\n\ntype Config struct {\n\tDatabaseURL string\n\tAPIPort     string\n}\n\nfunc Load() (*Config, error) {\n\tport := os.Getenv(\"API_PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\n\t// Validate port is a number\n\tif _, err := strconv.Atoi(port); err != nil {\n\t\tport = \"8080\"\n\t}\n\n\treturn \u0026Config{\n\t\tDatabaseURL: os.Getenv(\"DATABASE_URL\"),\n\t\tAPIPort:     port,\n\t}, nil\n}\n",
  "backend/pkg/logger/logger.go": "package logger\n\nimport (\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog\"\n)\n\nfunc New() zerolog.Logger {\n\treturn zerolog.New(zerolog.ConsoleWriter{Out: os.Stderr, TimeFormat: time.RFC3339}).\n\t\tLevel(zerolog.TraceLevel).\n\t\tWith().\n\t\tTimestamp().\n\t\tLogger()\n}\n",
  "deployments/docker-compose.yml": "version: '3.8'\n\nservices:\n  db:\n    image: postgres:14-alpine\n    container_name: ssc-db\n    environment:\n      POSTGRES_DB: ${POSTGRES_DB}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./seed/init.sql:/docker-entrypoint-initdb.d/init.sql\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n\n  minio:\n    image: minio/minio:latest\n    container_name: ssc-minio\n    ports:\n      - \"9000:9000\"\n      - \"9001:9001\"\n    environment:\n      MINIO_ROOT_USER: ${MINIO_ACCESS_KEY}\n      MINIO_ROOT_PASSWORD: ${MINIO_SECRET_KEY}\n    command: server /data --console-address \":9001\"\n    volumes:\n      - minio_data:/data\n\n  backend:\n    build:\n      context: ../backend\n      dockerfile: Dockerfile\n    container_name: ssc-backend\n    ports:\n      - \"${API_PORT}:${API_PORT}\"\n    depends_on:\n      db:\n        condition: service_healthy\n    environment:\n      - DATABASE_URL=${DATABASE_URL}\n      - API_PORT=${API_PORT}\n    env_file:\n      - ../.env\n\n  frontend:\n    image: nginx:alpine\n    container_name: ssc-frontend\n    ports:\n      - \"80:80\"\n    volumes:\n      - ../frontend:/usr/share/nginx/html\n    depends_on:\n      - backend\n\nvolumes:\n  postgres_data:\n  minio_data:\n",
  "deployments/seed/init.sql": "-- Enable extensions\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n-- Clear existing data and reset sequences\nTRUNCATE TABLE customers, images, build_events, sbom_records, cve_findings, attestations, customer_image_usage, sla_violations, notifications, audit_logs RESTART IDENTITY CASCADE;\n\n-- Create customers table to represent tenants\nCREATE TABLE IF NOT EXISTS customers (\n    namespace VARCHAR(255) PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    contact_info VARCHAR(255),\n    sla_tier VARCHAR(50) NOT NULL DEFAULT 'standard',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\n-- Create images table\nCREATE TABLE IF NOT EXISTS images (\n    id SERIAL PRIMARY KEY,\n    tenant_namespace VARCHAR(255) NOT NULL REFERENCES customers(namespace) ON DELETE CASCADE,\n    digest VARCHAR(255) UNIQUE NOT NULL,\n    tags TEXT[],\n    slsa_level INT,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\nCREATE INDEX IF NOT EXISTS idx_images_tenant_namespace ON images(tenant_namespace);\n\n-- Build Events Table\nCREATE TABLE IF NOT EXISTS build_events (\n    id SERIAL PRIMARY KEY,\n    tenant_namespace VARCHAR(255) NOT NULL REFERENCES customers(namespace) ON DELETE CASCADE,\n    image_id INT REFERENCES images(id) ON DELETE SET NULL, -- Allow image_id to be null if image is deleted\n    trigger_type VARCHAR(50) NOT NULL,\n    status VARCHAR(50) NOT NULL DEFAULT 'pending',\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\nCREATE INDEX IF NOT EXISTS idx_build_events_tenant_namespace ON build_events(tenant_namespace);\nCREATE INDEX IF NOT EXISTS idx_build_events_status ON build_events(status);\n\n-- Table for SBOM records\nCREATE TABLE IF NOT EXISTS sbom_records (\n    id SERIAL PRIMARY KEY,\n    image_id INT NOT NULL REFERENCES images(id) ON DELETE CASCADE,\n    format VARCHAR(50) NOT NULL, -- e.g., 'SPDX', 'CycloneDX'\n    uri VARCHAR(1024) NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\nCREATE INDEX IF NOT EXISTS idx_sbom_records_image_id ON sbom_records(image_id);\n\n-- Table for CVE findings\nCREATE TABLE IF NOT EXISTS cve_findings (\n    id SERIAL PRIMARY KEY,\n    image_id INT NOT NULL REFERENCES images(id) ON DELETE CASCADE,\n    cve_id VARCHAR(50) NOT NULL,\n    severity VARCHAR(50) NOT NULL, -- e.g., 'Critical', 'High', 'Medium', 'Low'\n    description TEXT,\n    fix_available BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\nCREATE INDEX IF NOT EXISTS idx_cve_findings_image_id ON cve_findings(image_id);\n\n-- Table for attestations\nCREATE TABLE IF NOT EXISTS attestations (\n    id SERIAL PRIMARY KEY,\n    image_id INT NOT NULL REFERENCES images(id) ON DELETE CASCADE,\n    type VARCHAR(100) NOT NULL, -- e.g., 'provenance', 'slsa'\n    uri VARCHAR(1024) NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\nCREATE INDEX IF NOT EXISTS idx_attestations_image_id ON attestations(image_id);\n\n-- New Tables for this step\nCREATE TABLE IF NOT EXISTS customer_image_usage (\n    id SERIAL PRIMARY KEY,\n    tenant_namespace VARCHAR(255) REFERENCES customers(namespace) ON DELETE CASCADE,\n    image_id INT REFERENCES images(id) ON DELETE CASCADE,\n    version_pinned BOOLEAN DEFAULT FALSE,\n    runtime_info VARCHAR(255),\n    created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\nCREATE TABLE IF NOT EXISTS sla_violations (\n    id SERIAL PRIMARY KEY,\n    tenant_namespace VARCHAR(255) REFERENCES customers(namespace) ON DELETE CASCADE,\n    cve_finding_id INT REFERENCES cve_findings(id) ON DELETE CASCADE,\n    status VARCHAR(50) DEFAULT 'active',\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    resolved_at TIMESTAMPTZ\n);\n\nCREATE TABLE IF NOT EXISTS notifications (\n    id SERIAL PRIMARY KEY,\n    tenant_namespace VARCHAR(255) REFERENCES customers(namespace) ON DELETE CASCADE,\n    type VARCHAR(100),\n    payload JSONB,\n    sent_at TIMESTAMPTZ,\n    status VARCHAR(50) DEFAULT 'pending'\n);\n\nCREATE TABLE IF NOT EXISTS audit_logs (\n    id SERIAL PRIMARY KEY,\n    tenant_namespace VARCHAR(255),\n    action VARCHAR(100),\n    actor VARCHAR(255),\n    details JSONB,\n    timestamp TIMESTAMPTZ DEFAULT NOW()\n);\n\n\n-- Seed Customers\nINSERT INTO customers (namespace, name, contact_info, sla_tier) VALUES\n('customer-a', 'Customer A Inc.', 'contact@customera.com', 'premium'),\n('customer-b', 'Customer B Corp.', 'support@customerb.com', 'standard');\n\n-- Seed Images\nINSERT INTO images (tenant_namespace, digest, tags, slsa_level) VALUES\n('customer-a', 'sha256:c3d3b3c3d3b3c3d3d3b3c3d3d3b3c3d3d3b3c3d3d3b3c3d3d3b3c3d3d3b3c3d3', '{\"1.0.0\", \"latest\"}', 3),\n('customer-a', 'sha256:a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1', '{\"1.0.1\"}', 3),\n('customer-a', 'sha256:b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2', '{\"2.0.0-clean\"}', 4),\n('customer-b', 'sha256:d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4', '{\"v1-stable\"}', 2);\n\n-- Seed SBOM Records\nINSERT INTO sbom_records (image_id, format, uri) VALUES\n(1, 'SPDX', 'minio://sboms/customer-a/image1-1.0.0.spdx.json'),\n(1, 'CycloneDX', 'minio://sboms/customer-a/image1-1.0.0.cyclonedx.json'),\n(2, 'SPDX', 'minio://sboms/customer-a/image2-1.0.1.spdx.json'),\n(4, 'SPDX', 'minio://sboms/customer-b/image4-v1-stable.spdx.json');\n\n-- Seed CVE Findings\nINSERT INTO cve_findings (image_id, cve_id, severity, description, fix_available) VALUES\n(1, 'CVE-2023-1111', 'Critical', 'Remote code execution vulnerability in lib-a.', true),\n(1, 'CVE-2023-2222', 'High', 'SQL injection in component-b.', false),\n(2, 'CVE-2023-3333', 'Medium', 'Cross-site scripting in web framework.', true),\n(4, 'CVE-2024-5555', 'High', 'Denial of service in network stack.', true);\n\n-- Seed Attestations\nINSERT INTO attestations (image_id, type, uri) VALUES\n(1, 'provenance', 'minio://attestations/customer-a/image1-provenance.json'),\n(1', 'vuln-scan', 'minio://attestations/customer-a/image1-vuln-scan.json'),\n(2, 'provenance', 'minio://attestations/customer-a/image2-provenance.json'),\n(3, 'provenance', 'minio://attestations/customer-a/image3-provenance.json'),\n(4, 'provenance', 'minio://attestations/customer-b/image4-provenance.json');\n\n-- Seed Build Events\nINSERT INTO build_events (tenant_namespace, image_id, trigger_type, status) VALUES\n('customer-a', 1, 'webhook', 'completed'),\n('customer-a', 2, 'manual', 'completed'),\n('customer-a', 3, 'scheduled', 'completed'),\n('customer-b', 4, 'api', 'completed'),\n('customer-b', NULL, 'webhook', 'pending'); -- A build that hasn't completed yet\n\n-- Seed Customer Image Usage\nINSERT INTO customer_image_usage (tenant_namespace, image_id, version_pinned, runtime_info) VALUES\n('customer-a', 1, true, 'prod-cluster-1'),\n('customer-a', 2, false, 'staging-cluster'),\n('customer-b', 4, true, 'prod-main');\n\n-- Seed SLA Violations\n-- Assuming CVE-2023-1111 (finding_id=1) for customer-a has breached the 'premium' SLA\nINSERT INTO sla_violations (tenant_namespace, cve_finding_id, status) VALUES\n('customer-a', 1, 'active');\n-- Assuming CVE-2024-5555 (finding_id=4) for customer-b has breached the 'standard' SLA\nINSERT INTO sla_violations (tenant_namespace, cve_finding_id, status) VALUES\n('customer-b', 4, 'active');\n\n\n-- Seed Notifications\nINSERT INTO notifications (tenant_namespace, type, payload, status) VALUES\n('customer-a', 'SLA_VIOLATION', '{\"cve_id\": \"CVE-2023-1111\", \"severity\": \"Critical\", \"image_digest\": \"sha256:c3d3...\"}', 'sent'),\n('customer-a', 'BUILD_COMPLETE', '{\"image_id\": 1, \"tags\": [\"1.0.0\", \"latest\"]}', 'sent');\n\n-- Seed Audit Logs\nINSERT INTO audit_logs (tenant_namespace, action, actor, details) VALUES\n('customer-a', 'build_triggered', 'webhook-service', '{\"trigger\": \"upstream_commit\", \"commit_sha\": \"abcdef123\"}'),\n('customer-a', 'image_published', 'system', '{\"image_id\": 1, \"digest\": \"sha256:c3d3...\"}'),\n('system', 'cve_registered', 'cve-scanner', '{\"cve_id\": \"CVE-2023-1111\", \"image_id\": 1}'),\n('customer-b', 'build_triggered', 'api-key-user', '{\"trigger\": \"manual_api_call\"}');",
  "docs/api.md": "# API Documentation\n\nThis document provides details on the REST API endpoints for the Secure Software Supply Chain MVP.\n\n## Authentication\n\nAll endpoints under the `/v1` path require authentication. For this MVP, authentication is mocked and can be provided in one of two ways:\n\n1.  **API Key**: Include an `X-API-Key` header with the value `mock-api-key`.\n2.  **Bearer Token**: Include an `Authorization` header with the value `Bearer mock-jwt-token`.\n\n**Example:**\n```sh\ncurl -H \"X-API-Key: mock-api-key\" http://localhost:8080/v1/images\n```\n\n---\n\n## Endpoints\n\n### Images\n\n#### List Images\n\n- **Endpoint**: `GET /v1/images`\n- **Description**: Retrieves a list of all published images.\n- **Success Response (200 OK)**:\n  ```json\n  [\n    {\n      \"id\": 1,\n      \"tenant_namespace\": \"customer-a\",\n      \"digest\": \"sha256:c3d3b3c3d3...\",\n      \"tags\": [\"1.0.0\", \"latest\"],\n      \"slsa_level\": 3,\n      \"created_at\": \"2023-10-27T10:00:00Z\",\n      \"updated_at\": \"2023-10-27T10:00:00Z\"\n    }\n  ]\n  ```\n\n#### Get Image by ID\n\n- **Endpoint**: `GET /v1/images/{id}`\n- **Description**: Retrieves a single image by its unique ID.\n- **Success Response (200 OK)**:\n  ```json\n  {\n    \"id\": 1,\n    \"tenant_namespace\": \"customer-a\",\n    \"digest\": \"sha256:c3d3b3c3d3...\",\n    \"tags\": [\"1.0.0\", \"latest\"],\n    \"slsa_level\": 3,\n    \"created_at\": \"2023-10-27T10:00:00Z\",\n    \"updated_at\": \"2023-10-27T10:00:00Z\"\n  }\n  ```\n- **Error Response (404 Not Found)**: If the image does not exist.\n\n#### Trigger New Image Build\n\n- **Endpoint**: `POST /v1/images`\n- **Description**: Simulates triggering a new image build. This creates a `build_event` record with a `pending` status and starts an asynchronous (mocked) build process.\n- **Request Body**:\n  ```json\n  {\n    \"tenant_namespace\": \"customer-a\"\n  }\n  ```\n- **Success Response (202 Accepted)**:\n  ```json\n  {\n    \"id\": 5,\n    \"tenant_namespace\": \"customer-a\",\n    \"image_id\": null,\n    \"trigger_type\": \"api\",\n    \"status\": \"pending\",\n    \"created_at\": \"2023-10-27T12:00:00Z\",\n    \"updated_at\": \"2023-10-27T12:00:00Z\"\n  }\n  ```\n\n#### Get Image SBOMs\n\n- **Endpoint**: `GET /v1/images/{id}/sbom`\n- **Description**: Retrieves SBOM metadata for a given image. (Currently mocked).\n- **Success Response (200 OK)**:\n  ```json\n  [\n    { \"format\": \"SPDX\", \"uri\": \"minio://sboms/...\" },\n    { \"format\": \"CycloneDX\", \"uri\": \"minio://sboms/...\" }\n  ]\n  ```\n\n#### Get Image CVEs\n\n- **Endpoint**: `GET /v1/images/{id}/cves`\n- **Description**: Retrieves CVE findings for a given image. (Currently mocked).\n- **Success Response (200 OK)**:\n  ```json\n  [\n    { \"cve_id\": \"CVE-2023-1111\", \"severity\": \"Critical\", \"fix_available\": true },\n    { \"cve_id\": \"CVE-2023-2222\", \"severity\": \"High\", \"fix_available\": false }\n  ]\n  ```\n\n#### Get Image Verification Data\n\n- **Endpoint**: `GET /v1/images/{id}/verify`\n- **Description**: Retrieves attestation and verification metadata for a given image. (Currently mocked).\n- **Success Response (200 OK)**:\n  ```json\n  {\n    \"signature\": { \"key_id\": \"cosign-key-1\", \"rekor_entry_uri\": \"https://rekor.mock.dev/12345\" },\n    \"attestations\": [\n      { \"type\": \"provenance\", \"uri\": \"minio://attestations/...\" },\n      { \"type\": \"vuln-scan\", \"uri\": \"minio://attestations/...\" }\n    ]\n  }\n  ```\n\n### Webhooks\n\n#### Trigger Upstream Build\n\n- **Endpoint**: `POST /v1/webhooks/upstream`\n- **Description**: A dedicated endpoint for triggering a build from a simulated upstream event (e.g., a Git commit).\n- **Request Body**:\n  ```json\n  {\n    \"tenant_namespace\": \"customer-b\"\n  }\n  ```\n- **Success Response (202 Accepted)**: Returns the created `build_event` object, similar to `POST /v1/images`.\n\n### Customers\n\n#### List Customers\n\n- **Endpoint**: `GET /v1/customers`\n- **Description**: Retrieves a list of all tenants/customers.\n- **Success Response (200 OK)**:\n  ```json\n  [\n    {\n      \"namespace\": \"customer-a\",\n      \"name\": \"Customer A Inc.\",\n      \"contact_info\": \"contact@customera.com\",\n      \"sla_tier\": \"premium\",\n      \"created_at\": \"2023-10-27T09:00:00Z\",\n      \"updated_at\": \"2023-10-27T09:00:00Z\"\n    }\n  ]\n  ```\n\n#### Get Customer by Namespace\n\n- **Endpoint**: `GET /v1/customers/{namespace}`\n- **Description**: Retrieves a single customer by their unique namespace.\n- **Success Response (200 OK)**: Returns a single customer object.\n- **Error Response (404 Not Found)**: If the customer does not exist.\n",
  "docs/architecture.md": "# Architecture Documentation\n\n## Overview\n\nThis document summarizes the finalized Minimum Viable Product (MVP) for a simulated secure software supply chain platform. Inspired by tools like Chainguard, Cosign, Sigstore, and SLSA, the MVP provides a demo-capable system that models how organizations can build, verify, distribute, and track container images in a secure, traceable, and auditable manner.\n\nThe system is built using containerized services orchestrated via `docker-compose`, and is suitable for demo environments, internal prototyping, or design validation.\n\n---\n\n## Product Vision\n\nThe platform allows organizations (tenants) to:\n\n- Simulate secure image builds and distribution pipelines.\n- Track metadata including SBOMs, provenance, attestations, and CVEs.\n- Model SLA compliance for CVE remediation.\n- Observe image lineage, tenant usage, and build provenance.\n- Serve as an educational or decision-support tool to evaluate secure supply chain needs.\n\n---\n\n## Key MVP Goals\n\n- **Security-First Design**: Images carry associated metadata like signed SBOMs, provenance, and build attestations (simulated).\n- **Traceability**: Builds are linked to source events (e.g. upstream changes, CVE discovery, or scheduled rebuilds).\n- **Multi-Tenant Support**: Tenants are logically isolated and tracked across the system using a `tenant_namespace`.\n- **SBOM Handling**: SBOMs are generated in both SPDX and CycloneDX formats and stored in an accessible object store (MinIO).\n- **CVE Monitoring**: Each image is scanned for known vulnerabilities, triggering SLA timers and alerting logic.\n- **Explorability**: A minimalistic web frontend supports exploration of images, metadata, and CVE details.\n- **Simulated Systems**: All integrations with external systems (e.g. Rekor, Sigstore, CVE databases) are stubbed or mocked.\n\n---\n\n## Architecture Overview\n\n### Services \u0026 Components\n\n| Component                 | Description                                                                 |\n|---------------------------|-----------------------------------------------------------------------------|\n| **Backend (Go)**          | Serves the REST API, implements business logic using Clean Architecture.    |\n| **Metadata DB (PostgreSQL)**| Stores all structured image, build, CVE, and tenant data.                   |\n| **Object Store (MinIO)**  | Stores build logs, SBOM files, attestations, and provenance documents.      |\n| **Frontend (Nginx)**      | Serves the static Vanilla JS frontend for the user interface.               |\n\nAll services are containerized and orchestrated via `docker-compose`.\n\n---\n\n## Data Model Highlights\n\n### Core Tables\n\n- `images`: Image metadata including digest, tags, associated SBOMs, and SLSA level.\n- `build_events`: Track origin (e.g. upstream trigger, CVE), build status, and timestamps.\n- `sbom_records`: SBOM format, URI, associated image.\n- `cve_findings`: CVEs tied to specific images, with fix availability and risk rating.\n- `attestations`: Simulated signed metadata linking image, build, and SBOMs.\n- `customers`: Registered tenants; includes metadata like contact info and SLA tier.\n- `customer_image_usage`: Maps image usage per tenant, version pinning, and runtime info.\n- `sla_violations`: Tracks when CVEs exceed SLA deadlines and trigger escalations.\n- `notifications`: Sent alerts related to builds, CVEs, or SLA breaches.\n- `audit_logs`: Signed log entries of sensitive actions (e.g. CVE registration, signature generation).\n\n### Design Considerations\n\n- All metadata is tenant-aware via `tenant_namespace`.\n- Rich join queries support lineage analysis (e.g. \"Which customers use an image affected by CVE-1234?\").\n- Timestamped metadata supports auditing and SLA monitoring.\n\n---\n\n## Simulated Workflows\n\n### 1. Build Trigger → Image Publication\n\n- **Triggered by**:\n  - Upstream code change (mock webhook via `POST /v1/webhooks/upstream`)\n  - Manual API call (`POST /v1/images`)\n  - Periodic rebuild (simulated cron)\n  - CVE discovery in base image\n- **Process**:\n  - An orchestrator service (mocked) simulates a build.\n  - A `build_event` is created in `pending` state.\n  - Upon completion (simulated), the orchestrator calls back to the API to finalize the build.\n  - Artifacts (logs, SBOMs, attestations) are stored in MinIO.\n  - The database is updated with image, build, and artifact metadata.\n  - The `build_event` is updated to `completed`.\n\n### 2. CVE Detection → SLA Escalation\n\n- A CVE scanner (mocked) assigns mock CVEs to affected images.\n- An SLA timer is calculated based on severity and customer SLA policy.\n- If a CVE is not fixed in time, an entry in `sla_violations` is created, triggering a simulated alert.\n- The UI or API can list current SLA violations by tenant or severity.\n\n---\n\n## Security Model (Simulated)\n\n| Area              | Approach                                                                 |\n|-------------------|--------------------------------------------------------------------------|\n| **Auth**          | Mock API keys and JWT for API access.                                    |\n| **RBAC**          | Basic tenant/user scoping via `tenant_namespace`.                        |\n| **Signing**       | Mocked Cosign-style signatures for images and attestations.              |\n| **SBOM Format**   | SPDX and CycloneDX stored in MinIO, referenced via URIs.                 |\n| **Audit Logging** | Log entries in `audit_logs` per sensitive event.                         |\n| **Vuln Scan**     | Simulated CVE ingestion with timestamps, fixability, and CVSS scoring.   |\n\n\u003e **Note:** All security flows are simulated for the MVP and are not suitable for production use.\n\n---\n\n## Frontend UI\n\n- Built with plain JavaScript, no framework.\n- **Pages**:\n  - **Image Explorer**: List and filter available images.\n  - **Image Detail View**: Show SBOM links, CVEs, provenance data.\n- Static assets are served via Nginx.\n\n---\n\n## Out-of-Scope for MVP\n\n- Real-time CVE feeds (e.g. NVD, OSV).\n- Production-ready cryptographic signature validation.\n- OCI registry push/pull integrations.\n- Role-based UI access.\n- Complex frontend features (e.g. search suggestions, charts).\n```",
  "frontend/css/style.css": "body {\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n    line-height: 1.6;\n    background-color: #f4f7f9;\n    color: #333;\n    margin: 0;\n}\n\nheader {\n    background-color: #2c3e50;\n    color: #ecf0f1;\n    padding: 1rem 2rem;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\nheader h1 {\n    margin: 0;\n    font-size: 1.5rem;\n}\n\nheader h1 a {\n    color: #ecf0f1;\n    text-decoration: none;\n}\n\n#auth-controls button {\n    background-color: #3498db;\n    color: white;\n    border: none;\n    padding: 0.5rem 1rem;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9rem;\n}\n\n#auth-controls button:hover {\n    background-color: #2980b9;\n}\n\nmain {\n    max-width: 1200px;\n    margin: 2rem auto;\n    padding: 0 1rem;\n}\n\n.card {\n    background-color: #fff;\n    padding: 1.5rem;\n    border-radius: 8px;\n    box-shadow: 0 2px 10px rgba(0,0,0,0.05);\n    margin-bottom: 1.5rem;\n}\n\n.card h2 {\n    margin-top: 0;\n    padding-bottom: 0.5rem;\n    border-bottom: 1px solid #eee;\n}\n\n.image-table {\n    width: 100%;\n    border-collapse: collapse;\n}\n\n.image-table th, .image-table td {\n    padding: 0.75rem;\n    text-align: left;\n    border-bottom: 1px solid #ddd;\n}\n\n.image-table th {\n    background-color: #f2f2f2;\n    font-weight: 600;\n}\n\n.image-table tbody tr:hover {\n    background-color: #f9f9f9;\n}\n\n.btn {\n    display: inline-block;\n    padding: 0.5rem 1rem;\n    background-color: #3498db;\n    color: #fff;\n    text-decoration: none;\n    border-radius: 4px;\n    border: none;\n    cursor: pointer;\n    font-size: 0.9rem;\n}\n\n.btn:hover {\n    background-color: #2980b9;\n}\n\n.back-link {\n    display: inline-block;\n    margin-bottom: 1rem;\n    color: #3498db;\n    text-decoration: none;\n    font-weight: 600;\n}\n\n.back-link:hover {\n    text-decoration: underline;\n}\n\n.grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 1.5rem;\n}\n\n.detail-list {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n}\n\n.detail-list li {\n    padding: 0.75rem 0;\n    border-bottom: 1px solid #eee;\n}\n\n.detail-list li:last-child {\n    border-bottom: none;\n}\n\n.detail-list strong {\n    display: block;\n    margin-bottom: 0.25rem;\n    color: #555;\n}\n\n.tag {\n    display: inline-block;\n    background-color: #e0e0e0;\n    color: #555;\n    padding: 0.2rem 0.5rem;\n    border-radius: 12px;\n    font-size: 0.8rem;\n    margin-right: 0.3rem;\n}\n\n.severity-Critical { color: #c0392b; font-weight: bold; }\n.severity-High { color: #e67e22; font-weight: bold; }\n.severity-Medium { color: #f1c40f; }\n.severity-Low { color: #7f8c8d; }\n",
  "frontend/index.html": "\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eSecure Software Supply Chain MVP\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"css/style.css\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cheader\u003e\n        \u003ch1\u003e\u003ca href=\"#\"\u003eSecure Software Supply Chain MVP\u003c/a\u003e\u003c/h1\u003e\n        \u003cdiv id=\"auth-controls\"\u003e\u003c/div\u003e\n    \u003c/header\u003e\n\n    \u003cmain id=\"app\"\u003e\n        Loading...\n    \u003c/main\u003e\n\n    \u003cscript type=\"module\" src=\"js/main.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n",
  "frontend/js/api.js": "import { getToken } from './auth.js';\n\nconst BASE_URL = '/v1';\n\nasync function fetchJSON(url, options = {}) {\n    const headers = {\n        'Content-Type': 'application/json',\n        ...options.headers,\n    };\n\n    const token = getToken();\n    if (token) {\n        headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    try {\n        const response = await fetch(url, { ...options, headers });\n\n        if (!response.ok) {\n            const errorData = await response.json().catch(() =\u003e ({ message: response.statusText }));\n            throw new Error(`API Error: ${response.status} ${errorData.message || response.statusText}`);\n        }\n\n        if (response.status === 204) { // No Content\n            return null;\n        }\n\n        return response.json();\n    } catch (error) {\n        console.error('API call failed:', error);\n        throw error;\n    }\n}\n\nexport const apiClient = {\n    getImages: () =\u003e fetchJSON(`${BASE_URL}/images`),\n    getImage: (id) =\u003e fetchJSON(`${BASE_URL}/images/${id}`),\n    getImageSBOMs: (id) =\u003e fetchJSON(`${BASE_URL}/images/${id}/sbom`),\n    getImageCVEs: (id) =\u003e fetchJSON(`${BASE_URL}/images/${id}/cves`),\n    getImageVerification: (id) =\u003e fetchJSON(`${BASE_URL}/images/${id}/verify`),\n};\n",
  "frontend/js/auth.js": "const TOKEN_KEY = 'authToken';\n\nexport function login() {\n    // In a real OIDC flow, this would redirect to an identity provider.\n    // For this mock, we just set a hardcoded token.\n    localStorage.setItem(TOKEN_KEY, 'mock-jwt-token');\n    console.log('Mock login successful.');\n}\n\nexport function logout() {\n    localStorage.removeItem(TOKEN_KEY);\n    console.log('Logged out.');\n}\n\nexport function getToken() {\n    return localStorage.getItem(TOKEN_KEY);\n}\n\nexport function isAuthenticated() {\n    return !!getToken();\n}\n",
  "frontend/js/components/imageDetail.js": "function renderCVEs(cves) {\n    if (!cves || cves.length === 0) {\n        return '\u003cp\u003eNo CVEs found for this image.\u003c/p\u003e';\n    }\n    return `\n        \u003cul class=\"detail-list\"\u003e\n            ${cves.map(cve =\u003e `\n                \u003cli\u003e\n                    \u003cstrong class=\"severity-${cve.severity}\"\u003e${cve.cve_id}\u003c/strong\u003e\n                    \u003cspan\u003e(${cve.severity}) - ${cve.fix_available ? 'Fix Available' : 'No Fix'}\u003c/span\u003e\n                \u003c/li\u003e\n            `).join('')}\n        \u003c/ul\u003e\n    `;\n}\n\nfunction renderSBOMs(sboms) {\n    if (!sboms || sboms.length === 0) {\n        return '\u003cp\u003eNo SBOMs found.\u003c/p\u003e';\n    }\n    return `\n        \u003cul class=\"detail-list\"\u003e\n            ${sboms.map(sbom =\u003e `\n                \u003cli\u003e\n                    \u003cstrong\u003e${sbom.format}\u003c/strong\u003e\n                    \u003ca href=\"${sbom.uri}\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e${sbom.uri}\u003c/a\u003e\n                \u003c/li\u003e\n            `).join('')}\n        \u003c/ul\u003e\n    `;\n}\n\nfunction renderVerification(verification) {\n    return `\n        \u003cul class=\"detail-list\"\u003e\n            \u003cli\u003e\u003cstrong\u003eSignature Key ID\u003c/strong\u003e \u003ccode\u003e${verification.signature.keyId}\u003c/code\u003e\u003c/li\u003e\n            \u003cli\u003e\u003cstrong\u003eRekor Entry\u003c/strong\u003e \u003ca href=\"${verification.rekorEntry}\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eView Entry\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n        \u003ch4\u003eAttestations\u003c/h4\u003e\n        \u003cul class=\"detail-list\"\u003e\n            ${verification.attestations.map(att =\u003e `\n                \u003cli\u003e\n                    \u003cstrong\u003e${att.type}\u003c/strong\u003e\n                    \u003ca href=\"${att.uri}\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e${att.uri}\u003c/a\u003e\n                \u003c/li\u003e\n            `).join('')}\n        \u003c/ul\u003e\n    `;\n}\n\nexport function renderImageDetail({ image, sboms, cves, verification }) {\n    return `\n        \u003ca href=\"#\" class=\"back-link\"\u003e\u0026larr; Back to Image List\u003c/a\u003e\n        \u003cdiv class=\"card\"\u003e\n            \u003ch2\u003eImage Details: \u003ccode style=\"font-size: 1.1rem;\"\u003e${image.digest.substring(0, 20)}...\u003c/code\u003e\u003c/h2\u003e\n            \u003cul class=\"detail-list\"\u003e\n                \u003cli\u003e\u003cstrong\u003eID\u003c/strong\u003e ${image.id}\u003c/li\u003e\n                \u003cli\u003e\u003cstrong\u003eTenant\u003c/strong\u003e ${image.tenant_namespace}\u003c/li\u003e\n                \u003cli\u003e\u003cstrong\u003eDigest\u003c/strong\u003e \u003ccode\u003e${image.digest}\u003c/code\u003e\u003c/li\u003e\n                \u003cli\u003e\u003cstrong\u003eTags\u003c/strong\u003e ${image.tags ? image.tags.map(tag =\u003e `\u003cspan class=\"tag\"\u003e${tag}\u003c/span\u003e`).join(' ') : 'None'}\u003c/li\u003e\n                \u003cli\u003e\u003cstrong\u003eSLSA Level\u003c/strong\u003e ${image.slsa_level}\u003c/li\u003e\n                \u003cli\u003e\u003cstrong\u003eCreated At\u003c/strong\u003e ${new Date(image.created_at).toLocaleString()}\u003c/li\u003e\n            \u003c/ul\u003e\n        \u003c/div\u003e\n\n        \u003cdiv class=\"grid\"\u003e\n            \u003cdiv class=\"card\"\u003e\n                \u003ch2\u003eCVE Findings\u003c/h2\u003e\n                ${renderCVEs(cves)}\n            \u003c/div\u003e\n            \u003cdiv class=\"card\"\u003e\n                \u003ch2\u003eSBOMs (Software Bill of Materials)\u003c/h2\u003e\n                ${renderSBOMs(sboms)}\n            \u003c/div\u003e\n        \u003c/div\u003e\n        \u003cdiv class=\"card\"\u003e\n            \u003ch2\u003eVerification \u0026 Attestations\u003c/h2\u003e\n            ${renderVerification(verification)}\n        \u003c/div\u003e\n    `;\n}\n```",
  "frontend/js/components/imageTable.js": "export function renderImageTable(images) {\n    if (!images || images.length === 0) {\n        return '\u003cdiv class=\"card\"\u003e\u003cp\u003eNo images found.\u003c/p\u003e\u003c/div\u003e';\n    }\n\n    const rows = images.map(image =\u003e `\n        \u003ctr\u003e\n            \u003ctd\u003e${image.id}\u003c/td\u003e\n            \u003ctd\u003e${image.tenant_namespace}\u003c/td\u003e\n            \u003ctd\u003e\u003ccode title=\"${image.digest}\"\u003e${image.digest.substring(0, 20)}...\u003c/code\u003e\u003c/td\u003e\n            \u003ctd\u003e${image.tags ? image.tags.map(tag =\u003e `\u003cspan class=\"tag\"\u003e${tag}\u003c/span\u003e`).join(' ') : ''}\u003c/td\u003e\n            \u003ctd\u003eSLSA ${image.slsa_level}\u003c/td\u003e\n            \u003ctd\u003e\u003ca href=\"#/images/${image.id}\" class=\"btn\"\u003eView Details\u003c/a\u003e\u003c/td\u003e\n        \u003c/tr\u003e\n    `).join('');\n\n    return `\n        \u003cdiv class=\"card\"\u003e\n            \u003ch2\u003eImage Explorer\u003c/h2\u003e\n            \u003ctable class=\"image-table\"\u003e\n                \u003cthead\u003e\n                    \u003ctr\u003e\n                        \u003cth\u003eID\u003c/th\u003e\n                        \u003cth\u003eTenant\u003c/th\u003e\n                        \u003cth\u003eDigest\u003c/th\u003e\n                        \u003cth\u003eTags\u003c/th\u003e\n                        \u003cth\u003eSLSA Level\u003c/th\u003e\n                        \u003cth\u003eActions\u003c/th\u003e\n                    \u003c/tr\u003e\n                \u003c/thead\u003e\n                \u003ctbody\u003e\n                    ${rows}\n                \u003c/tbody\u003e\n            \u003c/table\u003e\n        \u003c/div\u003e\n    `;\n}\n",
  "frontend/js/main.js": "import { apiClient } from './api.js';\nimport { renderImageTable } from './components/imageTable.js';\nimport { renderImageDetail } from './components/imageDetail.js';\nimport { isAuthenticated, login, logout } from './auth.js';\n\nconst app = document.getElementById('app');\nconst authControls = document.getElementById('auth-controls');\n\nconst showLoading = () =\u003e {\n    app.innerHTML = '\u003cdiv class=\"card\"\u003eLoading...\u003c/div\u003e';\n};\n\nconst showError = (message) =\u003e {\n    app.innerHTML = `\u003cdiv class=\"card\" style=\"color: red;\"\u003eError: ${message}\u003c/div\u003e`;\n};\n\nconst showLoginView = () =\u003e {\n    app.innerHTML = `\n        \u003cdiv class=\"card\"\u003e\n            \u003ch2\u003ePlease Log In\u003c/h2\u003e\n            \u003cp\u003eYou must be logged in to view the image catalog.\u003c/p\u003e\n        \u003c/div\u003e\n    `;\n};\n\nconst showImageListView = async () =\u003e {\n    showLoading();\n    try {\n        const images = await apiClient.getImages();\n        app.innerHTML = renderImageTable(images);\n    } catch (error) {\n        showError(error.message);\n        if (error.message.includes('401')) {\n            showLoginView();\n        }\n    }\n};\n\nconst showImageDetailView = async (id) =\u003e {\n    showLoading();\n    try {\n        const [image, sboms, cves, verification] = await Promise.all([\n            apiClient.getImage(id),\n            apiClient.getImageSBOMs(id),\n            apiClient.getImageCVEs(id),\n            apiClient.getImageVerification(id),\n        ]);\n        app.innerHTML = renderImageDetail({ image, sboms, cves, verification });\n    } catch (error) {\n        showError(error.message);\n    }\n};\n\nconst router = () =\u003e {\n    if (!isAuthenticated()) {\n        showLoginView();\n        return;\n    }\n\n    const hash = window.location.hash;\n    if (hash.startsWith('#/images/')) {\n        const id = hash.split('/')[2];\n        showImageDetailView(id);\n    } else {\n        showImageListView();\n    }\n};\n\nconst renderAuthUI = () =\u003e {\n    if (isAuthenticated()) {\n        authControls.innerHTML = '\u003cbutton id=\"logout-btn\"\u003eLogout\u003c/button\u003e';\n        document.getElementById('logout-btn').addEventListener('click', () =\u003e {\n            logout();\n            renderAuthUI();\n            router();\n        });\n    } else {\n        authControls.innerHTML = '\u003cbutton id=\"login-btn\"\u003eLogin\u003c/button\u003e';\n        document.getElementById('login-btn').addEventListener('click', () =\u003e {\n            login();\n            renderAuthUI();\n            router();\n        });\n    }\n};\n\nwindow.addEventListener('hashchange', router);\nwindow.addEventListener('DOMContentLoaded', () =\u003e {\n    renderAuthUI();\n    router();\n});"
}